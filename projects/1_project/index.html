<!DOCTYPE html>
<html lang="en">

  <!-- Head -->
  <head>    <!-- Metadata, OpenGraph and Schema.org -->
    

    <!-- Standard metadata -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Ian Martell | Sorting Your Marbles</title>
    <meta name="author" content="Ian Martell" />
    <meta name="description" content="Sorting Your Marbles overview" />
    <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website" />


    <!-- Bootstrap & MDB -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous" />

    <!-- Fonts & Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

    <!-- Code Syntax Highlighting -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="none" id="highlight_theme_light" />

    <!-- Styles -->
    
    <link rel="shortcut icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>⚡</text></svg>">
    
    <link rel="stylesheet" href="/assets/css/main.css">
    <link rel="canonical" href="https://ianmartell.github.io/projects/1_project/">
    
    <!-- Dark Mode -->
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark" />

    <script src="/assets/js/theme.js"></script>
    <script src="/assets/js/dark_mode.js"></script>
    

  </head>

  <!-- Body -->
  <body class="fixed-top-nav ">
  
    <!-- Header -->
    <header>
  
      <!-- Nav Bar -->
      <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
        <div class="container">
          <a class="navbar-brand title font-weight-lighter" href="https://ianmartell.github.io/"> <span
              class="font-weight-bold"> Ian </span> Martell</a>
              
          <!-- Social Icons -->
          <div class="navbar-brand social">
            <a href="mailto:goodusedigital@gmail.com" title="email"><i class="fas fa-envelope"></i></a>
            <a href="https://github.com/IanMartell" title="GitHub" target="_blank" rel="noopener noreferrer"><i class="fab fa-github"></i></a>
            <!-- <a href="https://www.linkedin.com/in/spencerpao" title="LinkedIn" target="_blank" rel="noopener noreferrer"><i class="fab fa-linkedin"></i></a>
            <a href="https://spencerpao.github.io/feed.xml" title="RSS Feed"><i class="fas fa-rss-square"></i></a> -->
            
          </div>

          <!-- Navbar Toggle -->
          <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav"
            aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar top-bar"></span>
            <span class="icon-bar middle-bar"></span>
            <span class="icon-bar bottom-bar"></span>
          </button>
  
          <div class="collapse navbar-collapse text-right" id="navbarNav">
            <ul class="navbar-nav ml-auto flex-nowrap">
  
              <!-- About -->
              <li class="nav-item ">
                <a class="nav-link" href="/">about</a>
              </li>
  
              <!-- Blog -->
              <li class="nav-item ">
                <a class="nav-link" href="/blog/">blog</a>
              </li>
  
              <!-- Other pages -->
              <li class="nav-item ">
                <a class="nav-link" href="/projects/">projects</a>
              </li>
  
              <!-- Toogle theme mode -->
              <div class="toggle-container">
                <a id="light-toggle">
                  <i class="fas fa-moon"></i>
                  <i class="fas fa-sun"></i>
                </a>
              </div>
            </ul>
          </div>
        </div>
      </nav>
    </header>
  
    <!-- Content -->
    <div class="container mt-5">
      <!-- page.html -->
      <div class="post">
  
        <header class="post-header">
          <a href="https://store.steampowered.com/app/3015900/Sorting_Your_Marbles/">
          <h1 class="post-title">Sorting Your Marbles</h1>
          </a>
          <p class="post-description">My debut title. The goal is simple: guide each colored marble to a flag of the same color by clicking on intersections to control the track's destination.</p>
        </header>

        <article>
          <div class="gifing float-right">
            <figure>
  
              <picture>
                <!-- <source media="(max-width: 480px)" srcset="/assets/img/prof_pic-480.webp" />
      <source media="(max-width: 800px)" srcset="/assets/img/prof_pic-800.webp" />
      <source media="(max-width: 1400px)" srcset="/assets/img/prof_pic-1400.webp" />
      -->
  
                <!-- Fallback to the original file -->
                 <a href="https://store.steampowered.com/app/3015900/Sorting_Your_Marbles/">
                  <img class="img-fluid z-dept-1 rounded" src="/assets/img/game.gif" alt="/assets/img/verticleStorCapsule.png">
                </a>
  
              </picture>
  
            </figure>
          </div>
  
          <div class="clearfix">
            <p> S.Y.M. is an arcade style, isometric, puzzle video game. As all game developers know: a product needs to be fun, but also (approximately) flawless. It's called polish; it's the icing without which there is no cake, and this cake is sweet. To play S.Y.M. for yourself you will need a steam account. If you email me I will provide keys for free access to the <a href="https://store.steampowered.com/app/3015900/Sorting_Your_Marbles/">product</a>. </p>
            
            <p> This title was born of a convergence of advancing accessability across a multitude of technologies. Blender in it's current state allows for graphics generation to rival pixar, or incredible work brevity at minimal fidelity expense. People choose blender for hobbyist projects for this accessability, but make no mistake; at it's full potential blender is quite robust. Unreal Engine likewise  endeavors to provide as much of it's cutting edge toolkit as intuitively and conviently as possible. Unreal is quite expansive. It prioritizes 3D games, with preferred model rendering workflows (supporting unparalled fidelity in multiple artistic styles) to streamline workflow. Unreal's intentional discriminations extend throughout the suite including preferrential methods of collision, physics interaction,  rendering; everything! While in some cases limiting, these restrictions allow smaller scale projects like S.Y.M. access to otherwise unattainably sophisticated techniques. For example: nanite. </p>
          </div>

          <div>
            <figure>
  
              <picture>
                <!-- <source media="(max-width: 480px)" srcset="/assets/img/prof_pic-480.webp" />
      <source media="(max-width: 800px)" srcset="/assets/img/prof_pic-800.webp" />
      <source media="(max-width: 1400px)" srcset="/assets/img/prof_pic-1400.webp" />
      -->
  
                <!-- Fallback to the original file -->
                 <a href="https://store.steampowered.com/app/3015900/Sorting_Your_Marbles/">
                  <img class="img-fluid z-dept-1 rounded" src="/assets/img/cloudA.gif" alt="/assets/img/secondAttemptCartoonTree.png">
                </a>
  
              </picture>
  
            </figure>
          </div>
        </article>
  
        <article>
          <p>When planning the procedural generation function it was decided the data should be organized into levels and groups. More on that later. Instead of keeping many different variables for all of this data, all of it is centralized under vectors. And so the procedural generation genesis began with a choice: multi-dimensional vectors (TArrays in this case), or housing multiple dimensions of data in a single dimension vector. </p>
          
          <p>TArray&lt TArray&lt TArray&lt vec2 &gt &gt &gt positionsNested VS TArray&lt vec2 &gt positionsFlat ?</p> 
          
          <p>It comes down to the memory expense vs. the processor expense. With many coding conventions it is preferred to <i>never</i> dynamically allocate memory. All of my vectors are declared and initialized in my header files with placeholder values. So which alternative takes up more memory? If I initiliaze positionsNested with 2 groups, each with 2 depth with 2 rows and 2 columns; will the amount of memory designated be the same as initializing positionsFlat with 16 values? No¹: vectors, and their common analogs, reallocate contiguous memory automatically, as needed. However at every reallocation more memory is reserved than immediately needed to minimize the number of reallocations. Therefore; while positionsNested and positionsFlat both contain exactly 16 vec2, every additional slot of memory alloted to positionsNested equates to 8 vec2. Compared to only 1 vec2 per slot regarding positionsFlat. It is possible to limit the memory reserved for positionsNested, but time consuming to figure out. For now positionsNested consumes more memory. ¹(“STD::Vector.” Cppreference.Com, <a href="https://en.cppreference.com/w/cpp/container/vector">en.cppreference.com/w/cpp/container/vector</a>. Accessed 22 Apr. 2025. )</p>

          <p>What about processor expense? </p>

          <img class="img-fluid z-dept-1 rounded" src="/assets/img/a/z.png" alt="Illustration of multi-dimensional vector composition">

          <p>The preceding illustration shows how to access the desired elements within a single dimensional vector organized to be multi-dimensional. Thats alot of calculation compared to simply inserting the desired value keys shown with the integersNested reference. Accept, that is actually what is happening behind the scenes in the case of the nested vector. The data stored within integersNested is stored in a single dimension in the memory; which is navigated implicitly just as we would explicitly. </p>

          <p>Considering these factors, Sorting Your Marbles implements multi-dimensional vectors. Although single dimensionality simplifies the memory allocation, the nested vectors are easier to read and write.</p>

          <p>These vectors; TArrays in unreal engines case, are the backbone of the procedural generation. How? it's quite simple:</p>
  
          <div class="row">
            <div class="col-sm mt-3 mt-md-0">
              <figure>

                <picture>
                  <!-- <source media="(max-width: 480px)" srcset="/assets/img/PTA-480.webp" />
    <source media="(max-width: 800px)" srcset="/assets/img/PTA-800.webp" />
    <source media="(max-width: 1400px)" srcset="/assets/img/PTA-1400.webp" />
    -->

                  <!-- Fallback to the original file -->
                  <img class="img-fluid rounded z-depth-1" src="/assets/img/a/a.png" title="figure 1">

                </picture>

              </figure>
            </div>
            <div class="col-sm mt-3 mt-md-0">
              <figure>

                <picture>
                  <!-- <source media="(max-width: 480px)" srcset="/assets/img/Arbitrage-480.webp" />
    <source media="(max-width: 800px)" srcset="/assets/img/Arbitrage-800.webp" />
    <source media="(max-width: 1400px)" srcset="/assets/img/Arbitrage-1400.webp" />
    -->

                  <!-- Fallback to the original file -->
                  <img class="img-fluid rounded z-depth-1" src="/assets/img/a/g.png"
                    title="figure 2">

                </picture>

              </figure>
            </div>
            <div class="col-sm mt-3 mt-md-0">
              <figure>

                <picture>
                  <!-- <source media="(max-width: 480px)" srcset="/assets/img/quant-480.webp" />
    <source media="(max-width: 800px)" srcset="/assets/img/quant-800.webp" />
    <source media="(max-width: 1400px)" srcset="/assets/img/quant-1400.webp" />
    -->

                  <!-- Fallback to the original file -->
                  <img class="img-fluid rounded z-depth-1" src="/assets/img/a/h.png" title="figure 3">

                </picture>

              </figure>
            </div>
          </div>
          <div>
            <ul>
              <li>First: a 15 by 15 tile grid is assumed.</li>
              <li>Second: track endpoints are designated randomly along the perimeter of the grid. As many different track endpoints as determined by the player in the level selector.</li>
              <li>Third: the endpoints are grouped into either a group of two, a group of four, or a group of eight. The size of the group is chosen randomly with even probability for any option. These groupings will procede until every endpoint has been grouped. For example, if there are seven endpoints, a group of two could be designated, then a group of four, then another group of four. The first two enpoints would be grouped, then the next four, then the last endpoint would be designated it's own group, by itself.</li>
            </ul>

            <p>The following code is how step two is accomplished. Forewarning: the code is tiresome. It is not recommended for casual readers.</p>

            <pre>
              <code>
void AMyHUD::GenerateHolePositions()
{
  int firstIndexOfCurrentPortionOfViableHolePositionsTempVar;
  int firstIndexOfCurrentPortionOfViableHolePositions = 0;
  int indexOfPreviousEvenHolePosition = 1;
  FVector2D centerOfRotation = FVector2D(8, 8);
  negativeOneZeroOrOne = FMath::RandRange(-1, 1);

  // below note holes is shorthand for endpoints. This section designates 
  // coordinates within the grid system which are be acceptable locations to 
  // place endpoints. The ammount of "viableHoleCoordinates" increases with the 
  // number of endpoints. notice in figure 2 the red dotted lines have no 
  // specified upper bound. It is variable.

  for (int a = 0; a < 12; a++)
  {
    for (int b = 0; b < 2; b++)
    {
      if ((15 - a) < FMath::Clamp((numberOfHoles - 4) / 2, 0, 6) + 9)
      {
        arrOfViableHoleCoordinates.Add(FVector2D(b + 14, 15 - a));
      }

    }
  } 

  arrOfViableHoleCoordinates.Append(arrOfViableHoleCoordinatesBase);
  // holeCoordinatesBase is the fully enclosed plot at the bottom of the figure. 
  // They are always the same so they are just listed out explicitly in the header file.

  for (int a = 0; a < 13; a++)
  {
    for (int b = 0; b < 2; b++)
    {
      if ((4 + a) < FMath::Clamp((numberOfHoles - 4) / 2, 0, 6) + 9)
      {
        arrOfViableHoleCoordinates.Add(FVector2D(2 - b, a + 4));
      }

    }
  }

  // The following code places endpoints somewhat randomly within the designated plots.

  for (int a = 1; a < numberOfHoles + 1; a++)
  {
    int evenHoleRowCorrectionFigure = pow(2 - (indexOfPreviousEvenHolePosition % 2), (a - 1) % 2);

    firstIndexOfCurrentPortionOfViableHolePositionsTempVar = (arrOfViableHoleCoordinates.Num() / 2 / numberOfHoles * a + FMath::RoundHalfFromZero(((float)((arrOfViableHoleCoordinates.Num() / 2) % numberOfHoles) / (float)numberOfHoles) * a)) * 2;

    // this above variable looks complicated but is exactly as it sounds. first 
    // it divides the quantity of viable spaces by two. This is to prevent an 
    // endpoint being placed directly behind another endpoint. then the halved 
    // quantity of viable coordinates is divided by the number of endpoints. this 
    // is the average size of each section of space within which an endpoints 
    // location is randomly chosen. The result of this figure multiplied by a, 
    // plus some other stuff, is the first index of the current portion of viable 
    // hole positions. current as relevant to a, being the index of a specific 
    // endpoint 

    int currentHolePositionCoordinateIndex = (FMath::RandRange(0, ((firstIndexOfCurrentPortionOfViableHolePositionsTempVar - firstIndexOfCurrentPortionOfViableHolePositions) / evenHoleRowCorrectionFigure) - 1) * evenHoleRowCorrectionFigure) + firstIndexOfCurrentPortionOfViableHolePositions;

    // currentHolePositionCoordinateIndex is the determination of where within 
    // the possible endpoint locations the current endpoint in question (a) is 
    // going to be placed.

    //test.Add(currentHolePositionCoordinateIndex);

    holePositions.Add(arrOfViableHoleCoordinates[currentHolePositionCoordinateIndex]);

    // holePositions is a 1 dimensional vec2 TArray. In the next section of the 
    // overarching procedural generation function holePositions will be placed 
    // into the multi-dimensional TArray as the foundational data. Why not do 
    // that here? because one of the dimensions is "grouping". The groupings have 
    // currently not yet been designated. the t

    firstIndexOfCurrentPortionOfViableHolePositions = firstIndexOfCurrentPortionOfViableHolePositionsTempVar;

    if ((a - 1) % 2 == 0)
    {
      indexOfPreviousEvenHolePosition = currentHolePositionCoordinateIndex;
    }
  }

  // below the rest of this code has the potential to rotate all of the endpoint 
  // coordinates by the center of the tile grid. If negativeOneZeroOrOne == -1 
  // the endpoints are rotated 90 degrees clockwise. If 1, 90 degrees counter 
  // clockwise. i.e if -1 the endpoints will no longer form a U shape, but 
  // instead a C shape on the screen.

  if (negativeOneZeroOrOne != 0)
  {
    holeCoordinateOrientation = 0;

    // elsewhere switches based on integers need to be consecutive this switch statement might glitch out
    switch (negativeOneZeroOrOne)
    {
    case -1:
      for (int a = 0; a < holePositions.Num(); a++)
      {
        FVector2D adjustedHolePosition = holePositions[a] - centerOfRotation;

        holePositions[a] = FVector2D(adjustedHolePosition.Y + centerOfRotation.X, -1 * adjustedHolePosition.X + centerOfRotation.Y);
      }

      break;
    case 1:
      for (int a = 0; a < holePositions.Num(); a++)
      {
        FVector2D adjustedHolePosition = holePositions[a] - centerOfRotation;

        holePositions[a] = FVector2D(-1 * adjustedHolePosition.Y + centerOfRotation.X, adjustedHolePosition.X + centerOfRotation.Y);
      }

      break;
    default:
      break;
    }
  }
  else
  {
    holeCoordinateOrientation = 1;
  }
  /*   nested TArray example
  nestedTArr.Add({ 1, 2, 3 });
  nestedTArr.Add({ 4, 5, 6 });
  nestedTArr[0].Add(7);*/
}
              </code>
            </pre>

          <br></br>

          <p>After GenerateHolePositions finishes GenerateTrackShape is called.This is where things start to get complicated. GenerateTrackShape is roughly 4k lines long, so instead of showing it all, it will be broken into chuncks.</p>

            <pre>
              <code>
void AMyHUD::GenerateTrackShape()
{
  int cumulativeGroupingCoverage = 0;
  int countOfLoopsOne = 0;
  TArray<FVector2D> vector2DStorArrOne;
  TArray<int> intStorArrOne;
  int currentGroupSize;
  int unpairedHoleOrIntersectionDir = 0;
  FVector2D unpairedHoleOrIntersectionPos = FVector2D(0, 0);
  int currentFirstOfPairHoleDir;
  TArray<int> firstOfPairHoleDirStorArr;
  TArray<FVector2D> firstOfPairHoleOrIntersectionPosStorArr;
  FVector2D differenceInPairPosition;
  FVector2D differenceInPairPositionAbsolute;
  int differenceInPairPositionClampedX;
  int differenceInPairPositionClampedY;
  TArray<int> availableTurnsPerPairBlockOfCurrentLevelCurrentGrouping;
  int currentATPPBOCLCG;
  TArray<int> verticleDistancesBetweenHolesOrIntersections;
  TArray<int> horizontalDistancesBetweenHolesOrIntersections;
  TArray<int> firstOfPairIsAboveSecondArr; //this array and firstOfPairIsEvenWithOrLeftOfSecondArr will need to have as many zeros as there are pairs for the first level of each group
  int currentFirstOfPairIsAboveSecond;
  TArray<int> firstOfPairIsEvenWithOrLeftOfSecondArr;
  int currentFirstOfPairIsEvenWithOrLeftOfSecond;
  TArray<TArray<int> > horizontalAndVerticleDistancesBetweenHolesOrIntersections = { { 0, 0, 0, 0 }, { 0, 0, 0, 0 } };
  TArray<int> relevantHorizontalAndVerticleDistances = { 0, 0 };
  TArray<int> whichOfEachPairsTurnsBecomesTheIntersection;
  TArray<int> turnDistancesFromFirstOfPairStorArr;
  TArray<int> amountOfTurnsPerDistance = { 0, 0 };
  TArray<int> turnDirectionsStorArr;// 0 for right, 1 for left, 2 for intersection, 3 for straight track
  TArray<int> oneZeroAlternatingArr = { 1, 0, 1, 0, 1 };
  TArray<int> zeroOneAlternatingArr = { 0, 1, 0, 1, 0 };
  FVector2D currentFirstOfPairHoleOrIntersectionPosition;//X being first
  int currentTurnDistance;
  int previousTurnDistance;
  FVector2D currentIntersectionPos;
  TArray<int> pairStartsOnSameSide;
  TArray<int> intersectionDirStorArr;
  TArray<int> intersectionOrientationStorArr;// 0 for right, 1 for left, 2 for straight
  TArray<int> intersectionAjustmentWeights;// 1 for first of pair, 2 for second of pair, 0 for neither
  FVector2D firstOfPairIntersectionPos;
  FVector2D secondOfPairIntersectionPos;
  int firstOfPairIntersectionDir;
  int secondOfPairIntersectionDir;
  bool oneLastThing = false;
  int topLevelIndex;

  // grouping holes in sets of 2, 4, or 8. These are the groupings spoken of in 
  // step 3.
  while (numberOfHoles > cumulativeGroupingCoverage)
  {
    switch (FMath::RandRange((int32)0, (int32)2))
    {
    case 0:
      listOfHolePositionGroupings.Add(2);
      cumulativeGroupingCoverage += 2;
      break;
    case 1:
      listOfHolePositionGroupings.Add(4);
      cumulativeGroupingCoverage += 4;
      break;
    case 2:
      listOfHolePositionGroupings.Add(8);
      cumulativeGroupingCoverage += 8;
      break;
    default:
      break;
    }
  }

  // cutting down the last grouping in the listOfHolePositionGroupings so the 
  // cummulative coverage is the same as the number of holes
  listOfHolePositionGroupings[listOfHolePositionGroupings.Num() - 1] = listOfHolePositionGroupings[listOfHolePositionGroupings.Num() - 1] - (cumulativeGroupingCoverage - numberOfHoles);

  // designating direction of the track leading away from the holes (its always 
  // toward the center) while grouping these designations to correspond with the 
  // holePositionGroupings, and reorganizing holePositions into 
  // holeAndIntersectionPositions while grouping them to correspond with 
  // holePositionGroupings. this is where the multi dimensional TArrays begin
  for (int a = 0; a < listOfHolePositionGroupings.Num(); a++)
  {
    for (int b = 0; b < listOfHolePositionGroupings[a]; b++)
    {
      vector2DStorArrOne.Add(holePositions[countOfLoopsOne]);

      if (holePositions[countOfLoopsOne].X > holePositions[countOfLoopsOne].Y)
      {
        if (16 - holePositions[countOfLoopsOne].X > holePositions[countOfLoopsOne].Y)
        {
          intStorArrOne.Add(1);
        }
        else
        {
          intStorArrOne.Add(4);
        }
      }
      else
      {
        if (holePositions[countOfLoopsOne].X > 16 - holePositions[countOfLoopsOne].Y)
        {
          intStorArrOne.Add(3);
        }
        else
        {
          intStorArrOne.Add(2);
        }
      }

      countOfLoopsOne++;
    }
    arrOfTrackDirectionsLeadingAwayFromEachHoleOrIntersection[0][a] = intStorArrOne;

    holeAndIntersectionPositions[0][a] = vector2DStorArrOne;

    intStorArrOne.Empty();
    vector2DStorArrOne.Empty();

  }
  if (numberOfHoles > 12)
  {
    switch (negativeOneZeroOrOne)
    {
    case -1:
      arrOfTrackDirectionsLeadingAwayFromEachHoleOrIntersection[0][0][0] = 1;
      arrOfTrackDirectionsLeadingAwayFromEachHoleOrIntersection[0][listOfHolePositionGroupings.Num() - 1][listOfHolePositionGroupings[listOfHolePositionGroupings.Num() - 1] - 1] = 3;
      break;
    case 0:
      arrOfTrackDirectionsLeadingAwayFromEachHoleOrIntersection[0][0][0] = 4;
      arrOfTrackDirectionsLeadingAwayFromEachHoleOrIntersection[0][listOfHolePositionGroupings.Num() - 1][listOfHolePositionGroupings[listOfHolePositionGroupings.Num() - 1] - 1] = 2;
      break;
    case 1:
      arrOfTrackDirectionsLeadingAwayFromEachHoleOrIntersection[0][0][0] = 3;
      arrOfTrackDirectionsLeadingAwayFromEachHoleOrIntersection[0][listOfHolePositionGroupings.Num() - 1][listOfHolePositionGroupings[listOfHolePositionGroupings.Num() - 1] - 1] = 1;
      break;
    default:
      break;
    }
  }
  countOfLoopsOne = 0;
              </code>
            </pre>
              
          </div>

          <br></br>  
  
          <div class="row">
            <div class="col-sm mt-3 mt-md-0">
              <figure>

                <picture>
                  <!-- <source media="(max-width: 480px)" srcset="/assets/img/CAPM-480.webp" />
    <source media="(max-width: 800px)" srcset="/assets/img/CAPM-800.webp" />
    <source media="(max-width: 1400px)" srcset="/assets/img/CAPM-1400.webp" />
    -->

                  <!-- Fallback to the original file -->
                  <img class="img-fluid rounded z-depth-1" src="/assets/img/a/i.png"
                    title="figure 4">

                </picture>

              </figure>
            </div>
            <div class="col-sm mt-3 mt-md-0">
              <figure>

                <picture>
                  <!-- <source media="(max-width: 480px)" srcset="/assets/img/dcf-480.webp" />
    <source media="(max-width: 800px)" srcset="/assets/img/dcf-800.webp" />
    <source media="(max-width: 1400px)" srcset="/assets/img/dcf-1400.webp" />
    -->

                  <!-- Fallback to the original file -->
                  <img class="img-fluid rounded z-depth-1" src="/assets/img/a/j.png" title="figure 5">

                </picture>

              </figure>
            </div>
            <div class="col-sm mt-3 mt-md-0">
              <figure>

                <picture>
                  <!-- <source media="(max-width: 480px)" srcset="/assets/img/scrapefin-480.webp" />
    <source media="(max-width: 800px)" srcset="/assets/img/scrapefin-800.webp" />
    <source media="(max-width: 1400px)" srcset="/assets/img/scrapefin-1400.webp" />
    -->

                  <!-- Fallback to the original file -->
                  <img class="img-fluid rounded z-depth-1" src="/assets/img/a/k.png" title="figure 6">

                </picture>

              </figure>
            </div>
          </div>
          <div>
            <ul>
              <li>Fourth: the endpoints are paired. If there are an odd number of endpoints one is left unpaired.</li>
              <li>Fifth: track is calculated between pairs. This includes the verticle and horizontal distance each section of track spans. Also where along those spans turns exist, and what exact orientation each turn has.</li>
              <li>Sixth: for each section of track one of the turns is designated as an intersection. For this to happen the turn must meet certain criteria.</li>
            </ul>

            <p>Once the groups have been established and the bottom level of data is populated in arrOfTrackDirectionsLeadingAwayFromEachHoleOrIntersection and holeAndIntersectionPositions; the cyclical stuff begins with the step 4 stuff.</p>

            <pre>
              <code>
  // This is where the master loop containing the all of the remaining sub 
  // processes for laying out the track is declared and initialized. Once this  
  // is done looping and the resulting data has been packaged, the track is 
  // ready for assembly.
  // so I think once this completes I will promote all the results into the 
  // same group on the 4th level and run the level stuff loop one last time. if 
  // it works out like this  the permanent storage will only have 1 
  // group for the fourth level and beyond. this would restrict players to a 
  // maximum of 16 endpoints but thats probably plenty
  for (int currentGroupIndex = 0; currentGroupIndex < listOfHolePositionGroupings.Num(); currentGroupIndex++)
  {
    currentGroupSize = listOfHolePositionGroupings[currentGroupIndex];
  
    for (int currentLevelIndex = 0; currentLevelIndex <= FMath::Clamp(FMath::RoundHalfFromZero((float)currentGroupSize / 2.0f), 1, 3) - 1; currentLevelIndex++)
    {
      if (currentLevelIndex == 0)
      {
        firstOfPairIsAboveSecondArr.Empty();
        firstOfPairIsEvenWithOrLeftOfSecondArr.Empty();
        intersectionAjustmentWeights.Empty();
  
        for (int a = 0; a < currentGroupSize / 2; a++)
        {
          firstOfPairIsAboveSecondArr.Add(0); //this is zero for each endpoint 
          // on the bottom level because the endpoint locations are generated in 
          // accordance with this condition
          firstOfPairIsEvenWithOrLeftOfSecondArr.Add(0);
          intersectionAjustmentWeights.Add(0);
        }
  
        //do I need to permanently store intersection adjustment weights here?
        firstOfPairIsAboveSecondAllPairs[0][currentGroupIndex] = firstOfPairIsAboveSecondArr;
        firstOfPairIsEvenWithOrLeftOfSecondAllPairs[0][currentGroupIndex] = firstOfPairIsEvenWithOrLeftOfSecondArr;
  
        vector2DStorArrOne = holeAndIntersectionPositions[currentLevelIndex][currentGroupIndex];
        intersectionDirStorArr = arrOfTrackDirectionsLeadingAwayFromEachHoleOrIntersection[currentLevelIndex][currentGroupIndex];
      }
  
      if (intersectionDirStorArr.Num() % 2 == 1)
      {
        unpairedHoleOrIntersectionDir = intersectionDirStorArr[intersectionDirStorArr.Num() - 1];
        unpairedHoleOrIntersectionPos = vector2DStorArrOne[vector2DStorArrOne.Num() - 1];
      }
  
      // designating the amount of turns to the next intersection per pair of 
      // holes or intersections, getting the distance between the holes or 
      // intersections and then getting the horizontal and verticle distance 
      // between the holes or intersections. Then checking if the first hole or 
      // intersection of a pair is "above" the other, or "even or left of" the 
      // other.
  
      for (int a = 1; a <= intersectionDirStorArr.Num() / 2; a++)//this won't run if there is only one element in the current group
      {
        currentFirstOfPairHoleDir = intersectionDirStorArr[a * 2 - 2];
        firstOfPairHoleDirStorArr.Add(currentFirstOfPairHoleDir);
        firstOfPairHoleOrIntersectionPosStorArr.Add(vector2DStorArrOne[a * 2 - 2]);
  
        differenceInPairPosition = firstOfPairHoleOrIntersectionPosStorArr[a - 1] - vector2DStorArrOne[a * 2 - 1];
        differenceInPairPositionAbsolute = differenceInPairPosition.GetAbs();
        differenceInPairPositionClampedX = FMath::Clamp(FMath::RoundToZero((float)differenceInPairPositionAbsolute.X / 2), 0, 2);
        differenceInPairPositionClampedY = FMath::Clamp(FMath::RoundToZero((float)differenceInPairPositionAbsolute.Y / 2), 0, 2);
  
        currentFirstOfPairIsAboveSecond = firstOfPairIsAboveSecondArr[a - 1];
        currentFirstOfPairIsEvenWithOrLeftOfSecond = firstOfPairIsEvenWithOrLeftOfSecondArr[a - 1];
  
        if (currentFirstOfPairHoleDir == intersectionDirStorArr[a * 2 - 1])
        {
          pairStartsOnSameSide.Add(1);
  
          if (differenceInPairPositionClampedX <= differenceInPairPositionClampedY)
          { 
            availableTurnsPerPairBlockOfCurrentLevelCurrentGrouping.Add(FMath::RandRange(firstOfPairIsEvenWithOrLeftOfSecondArr[a - 1], differenceInPairPositionClampedX) * 2 + 2);
          }
          else
          {
            availableTurnsPerPairBlockOfCurrentLevelCurrentGrouping.Add(FMath::RandRange(firstOfPairIsEvenWithOrLeftOfSecondArr[a - 1], differenceInPairPositionClampedY) * 2 + 2);
          }
  
          if (currentFirstOfPairIsAboveSecond)
          {
            switch (currentFirstOfPairHoleDir % 2)
            {
            case 0:
              horizontalDistancesBetweenHolesOrIntersections.Add(differenceInPairPositionAbsolute.Y);
              verticleDistancesBetweenHolesOrIntersections.Add(differenceInPairPositionAbsolute.X - 1);
              break;
            case 1:
              horizontalDistancesBetweenHolesOrIntersections.Add(differenceInPairPositionAbsolute.X);//do I need to roundHalfFromZero here or will it translate properly every time here. this could be a good chance to practice writing an error message generator
              verticleDistancesBetweenHolesOrIntersections.Add(differenceInPairPositionAbsolute.Y - 1);
              break;
            default:
              break;
            }
          }
          else if (currentFirstOfPairIsEvenWithOrLeftOfSecond)
          {
            switch (currentFirstOfPairHoleDir % 2)
            {
            case 0:
              horizontalDistancesBetweenHolesOrIntersections.Add(differenceInPairPositionAbsolute.Y + 1);
              verticleDistancesBetweenHolesOrIntersections.Add(differenceInPairPositionAbsolute.X + 1);
              break;
            case 1:
              horizontalDistancesBetweenHolesOrIntersections.Add(differenceInPairPositionAbsolute.X + 1);
              verticleDistancesBetweenHolesOrIntersections.Add(differenceInPairPositionAbsolute.Y + 1);
              break;
            default:
              break;
            }
          }
          else
          {
            switch (currentFirstOfPairHoleDir % 2)
            {
            case 0:
              horizontalDistancesBetweenHolesOrIntersections.Add(differenceInPairPositionAbsolute.Y);
              verticleDistancesBetweenHolesOrIntersections.Add(differenceInPairPositionAbsolute.X + 1);
              break;
            case 1:
              horizontalDistancesBetweenHolesOrIntersections.Add(differenceInPairPositionAbsolute.X);
              verticleDistancesBetweenHolesOrIntersections.Add(differenceInPairPositionAbsolute.Y + 1);
              break;
            default:
              break;
            }
          }
        }
        else
        {
          pairStartsOnSameSide.Add(0);
  
          if (differenceInPairPositionClampedX <= differenceInPairPositionClampedY)
          {
            availableTurnsPerPairBlockOfCurrentLevelCurrentGrouping.Add(FMath::RandRange(FMath::Clamp(firstOfPairIsAboveSecondArr[a - 1] + firstOfPairIsEvenWithOrLeftOfSecondArr[a - 1], 0, 1), differenceInPairPositionClampedX) * 2 + 1);// I just took off a * 2 from the end of the first argument of the RandRange 01/17/24
          }
          else
          {
            availableTurnsPerPairBlockOfCurrentLevelCurrentGrouping.Add(FMath::RandRange(FMath::Clamp(firstOfPairIsAboveSecondArr[a - 1] + firstOfPairIsEvenWithOrLeftOfSecondArr[a - 1], 0, 1), differenceInPairPositionClampedY) * 2 + 1);
          }
  
          if (currentFirstOfPairIsAboveSecond)
          {
            switch (currentFirstOfPairHoleDir % 2)
            {
            case 0:
              horizontalDistancesBetweenHolesOrIntersections.Add(differenceInPairPositionAbsolute.Y - 1);
              verticleDistancesBetweenHolesOrIntersections.Add(differenceInPairPositionAbsolute.X); //just changed this from +1 to + nothing 01/17/24 
              break;
            case 1:
              horizontalDistancesBetweenHolesOrIntersections.Add(differenceInPairPositionAbsolute.X - 1);
              verticleDistancesBetweenHolesOrIntersections.Add(differenceInPairPositionAbsolute.Y); //just changed this from +1 to + nothing 01/17/24 
              break;
            default:
              break;
            }
          }
          else if (currentFirstOfPairIsEvenWithOrLeftOfSecond)
          {
            switch (currentFirstOfPairHoleDir % 2)
            {
            case 0:
              horizontalDistancesBetweenHolesOrIntersections.Add(differenceInPairPositionAbsolute.Y + 1);
              verticleDistancesBetweenHolesOrIntersections.Add(differenceInPairPositionAbsolute.X);
              break;
            case 1:
              horizontalDistancesBetweenHolesOrIntersections.Add(differenceInPairPositionAbsolute.X + 1);
              verticleDistancesBetweenHolesOrIntersections.Add(differenceInPairPositionAbsolute.Y);
              break;
            default:
              break;
            }
          }
          else
          {
            switch (currentFirstOfPairHoleDir % 2)
            {
            case 0:
              horizontalDistancesBetweenHolesOrIntersections.Add(differenceInPairPositionAbsolute.Y - 1);
              verticleDistancesBetweenHolesOrIntersections.Add(differenceInPairPositionAbsolute.X);
              break;
            case 1:
              horizontalDistancesBetweenHolesOrIntersections.Add(differenceInPairPositionAbsolute.X - 1);
              verticleDistancesBetweenHolesOrIntersections.Add(differenceInPairPositionAbsolute.Y);
              break;
            default:
              break;
            }
          }
        }
      }
  
      horizontalAndVerticleDistancesBetweenHolesOrIntersections[0] = horizontalDistancesBetweenHolesOrIntersections;
      horizontalAndVerticleDistancesBetweenHolesOrIntersections[1] = verticleDistancesBetweenHolesOrIntersections;
              </code>
            </pre>

            <br></br>

            <p>Once the track between endpoint or intersection pairs, for this group, for this level, has been defined, an intersection will be determined from one of the turns.</p>

            <pre>
              <code>
      // determining the intersection location. I will also need to rework the 
      // first section of this master loop and at the very least determine 
      // firstOfPairIsAboveSecond and firstOfPairIsEvenWithOrLeftOfSecond here.

      vector2DStorArrOne.Empty();
      
      for (int currentPairIndex = 0; currentPairIndex < availableTurnsPerPairBlockOfCurrentLevelCurrentGrouping.Num(); currentPairIndex++)//Im not sure if this needs to run every pair or every holeOrIntersection, I think its pair
      {
        turnDistancesFromFirstOfPairStorArr = turnAndIntersectionDistancesPerPair[currentLevelIndex][currentGroupIndex][currentPairIndex];
        currentIntersectionPos = firstOfPairHoleOrIntersectionPosStorArr[currentPairIndex];
        //so now all I have to do today is finish this code section, and change the firstOfPairIsAboveSecond and firstOfPairIsEvenWithOrLeftOfSecond calculation to on this level after this. can you interweave adjusting the intersection position? come to think of it that will need to occur before calculating firstOfPairIsAboveSecond and firstOfPairIsEvenWithOrLeftOfSecond
      
        currentTurnDistance = turnDistancesFromFirstOfPairStorArr[whichOfEachPairsTurnsBecomesTheIntersection[currentPairIndex] - 1];
      
        if (whichOfEachPairsTurnsBecomesTheIntersection[currentPairIndex] != 1)
        {
          previousTurnDistance = turnDistancesFromFirstOfPairStorArr[whichOfEachPairsTurnsBecomesTheIntersection[currentPairIndex] - 2];//this should be a minus 2 
        }
        else
        {
          previousTurnDistance = 0;
        }
      
        // cases where firstOfPairIsAboveSecond are more complicated. I have 
        // settled on setting the first turn from the firstOfPair to be -1 
        // which should function properly now. however when I build the level I 
        // will need to pay special attention to this
      
        switch (firstOfPairHoleDirStorArr[currentPairIndex])
        {
        case 1:
          if (firstOfPairIsAboveSecondArr[currentPairIndex])//you still need to adjust how horizontal and verticle distances are calculated to account for if firstOfPairIsAboveSecond or if firstOfPairIsEvenWithOrLeftOfSecond
          {
            if (whichOfEachPairsTurnsBecomesTheIntersection[currentPairIndex] % 2 == 1)
            {
              currentIntersectionPos.X -= previousTurnDistance;
              currentIntersectionPos.Y -= currentTurnDistance;
            }
            else
            {
              currentIntersectionPos.X -= currentTurnDistance;
              currentIntersectionPos.Y -= previousTurnDistance;
            }
      
            vector2DStorArrOne.Add(currentIntersectionPos);
          }
          else if (firstOfPairIsEvenWithOrLeftOfSecondArr[currentPairIndex])
          {
            if (whichOfEachPairsTurnsBecomesTheIntersection[currentPairIndex] % 2 == 1)
            {
              currentIntersectionPos.X += previousTurnDistance;
              currentIntersectionPos.Y += currentTurnDistance;
            }
            else
            {
              currentIntersectionPos.X += currentTurnDistance;
              currentIntersectionPos.Y += previousTurnDistance;
            }
      
            vector2DStorArrOne.Add(currentIntersectionPos);
          }
          else
          {
            if (whichOfEachPairsTurnsBecomesTheIntersection[currentPairIndex] % 2 == 1)
            {
              currentIntersectionPos.X -= previousTurnDistance;
              currentIntersectionPos.Y += currentTurnDistance;
            }
            else
            {
              currentIntersectionPos.X -= currentTurnDistance;
              currentIntersectionPos.Y += previousTurnDistance;
            }
      
            vector2DStorArrOne.Add(currentIntersectionPos);
          }
      
          break;
        case 2:
          if (firstOfPairIsAboveSecondArr[currentPairIndex])
          {
            if (whichOfEachPairsTurnsBecomesTheIntersection[currentPairIndex] % 2 == 1)
            {
              currentIntersectionPos.X -= currentTurnDistance;
              currentIntersectionPos.Y += previousTurnDistance;
            }
            else
            {
              currentIntersectionPos.X -= previousTurnDistance;
              currentIntersectionPos.Y += currentTurnDistance;
            }
      
            vector2DStorArrOne.Add(currentIntersectionPos);
          }
          else if (firstOfPairIsEvenWithOrLeftOfSecondArr[currentPairIndex])
          {
            if (whichOfEachPairsTurnsBecomesTheIntersection[currentPairIndex] % 2 == 1)
            {
              currentIntersectionPos.X += currentTurnDistance;
              currentIntersectionPos.Y -= previousTurnDistance;
            }
            else
            {
              currentIntersectionPos.X += previousTurnDistance;
              currentIntersectionPos.Y -= currentTurnDistance;
            }
      
            vector2DStorArrOne.Add(currentIntersectionPos);
          }
          else
          {
            if (whichOfEachPairsTurnsBecomesTheIntersection[currentPairIndex] % 2 == 1)
            {
              currentIntersectionPos.X += currentTurnDistance;
              currentIntersectionPos.Y += previousTurnDistance;
            }
            else
            {
              currentIntersectionPos.X += previousTurnDistance;
              currentIntersectionPos.Y += currentTurnDistance;
            }
      
            vector2DStorArrOne.Add(currentIntersectionPos);
          }
      
          break;
        case 3:
          if (firstOfPairIsAboveSecondArr[currentPairIndex])
          {
            if (whichOfEachPairsTurnsBecomesTheIntersection[currentPairIndex] % 2 == 1)
            {
              currentIntersectionPos.X += previousTurnDistance;
              currentIntersectionPos.Y += currentTurnDistance;
            }
            else
            {
              currentIntersectionPos.X += currentTurnDistance;
              currentIntersectionPos.Y += previousTurnDistance;
            }
      
            vector2DStorArrOne.Add(currentIntersectionPos);
          }
          else if (firstOfPairIsEvenWithOrLeftOfSecondArr[currentPairIndex])
          {
            if (whichOfEachPairsTurnsBecomesTheIntersection[currentPairIndex] % 2 == 1)
            {
              currentIntersectionPos.X -= previousTurnDistance;
              currentIntersectionPos.Y -= currentTurnDistance;
            }
            else
            {
              currentIntersectionPos.X -= currentTurnDistance;
              currentIntersectionPos.Y -= previousTurnDistance;
            }
      
            vector2DStorArrOne.Add(currentIntersectionPos);
          }
          else
          {
            if (whichOfEachPairsTurnsBecomesTheIntersection[currentPairIndex] % 2 == 1)
            {
              currentIntersectionPos.X += previousTurnDistance;
              currentIntersectionPos.Y -= currentTurnDistance;
            }
            else
            {
              currentIntersectionPos.X += currentTurnDistance;
              currentIntersectionPos.Y -= previousTurnDistance;
            }
      
            vector2DStorArrOne.Add(currentIntersectionPos);
          }
      
          break;
        case 4:
          if (firstOfPairIsAboveSecondArr[currentPairIndex])
          {
            if (whichOfEachPairsTurnsBecomesTheIntersection[currentPairIndex] % 2 == 1)
            {
              currentIntersectionPos.X += currentTurnDistance;
              currentIntersectionPos.Y -= previousTurnDistance;
            }
            else
            {
              currentIntersectionPos.X += previousTurnDistance;
              currentIntersectionPos.Y -= currentTurnDistance;
            }
      
            vector2DStorArrOne.Add(currentIntersectionPos);
          }
          else if (firstOfPairIsEvenWithOrLeftOfSecondArr[currentPairIndex])
          {
            if (whichOfEachPairsTurnsBecomesTheIntersection[currentPairIndex] % 2 == 1)
            {
              currentIntersectionPos.X -= currentTurnDistance;
              currentIntersectionPos.Y += previousTurnDistance;
            }
            else
            {
              currentIntersectionPos.X -= previousTurnDistance;
              currentIntersectionPos.Y += currentTurnDistance;
            }
      
            vector2DStorArrOne.Add(currentIntersectionPos);
          }
          else
          {
            if (whichOfEachPairsTurnsBecomesTheIntersection[currentPairIndex] % 2 == 1)
            {
              currentIntersectionPos.X -= currentTurnDistance;
              currentIntersectionPos.Y -= previousTurnDistance;
            }
            else
            {
              currentIntersectionPos.X -= previousTurnDistance;
              currentIntersectionPos.Y -= currentTurnDistance;
            }
      
            vector2DStorArrOne.Add(currentIntersectionPos);
          }
      
          break;
        default:
          break;
        }
      }
      turnDistancesFromFirstOfPairStorArr.Empty();
      intersectionDirStorArr.Empty();
      
      //calculating newly generated intersection's directions and orientations
      for (int currentIntersection = 0; currentIntersection < vector2DStorArrOne.Num(); currentIntersection++)
      {
        currentFirstOfPairIsAboveSecond = firstOfPairIsAboveSecondArr[currentIntersection];
        currentFirstOfPairIsEvenWithOrLeftOfSecond = firstOfPairIsEvenWithOrLeftOfSecondArr[currentIntersection];
      
        if (pairStartsOnSameSide[currentIntersection])
        {
          intersectionDirStorArr.Add(firstOfPairHoleDirStorArr[currentIntersection]);
      
          if (whichOfEachPairsTurnsBecomesTheIntersection[currentIntersection] % 2)
          {
            intersectionOrientationStorArr.Add(1);
          }
          else
          {
            intersectionOrientationStorArr.Add(0);
          }
        }
        else
        {
          switch (firstOfPairHoleDirStorArr[currentIntersection])//are the 16s in this switch statement correct? I think so
          {
          case 1:
            if (currentFirstOfPairIsEvenWithOrLeftOfSecond)
            {
              if (whichOfEachPairsTurnsBecomesTheIntersection[currentIntersection] == availableTurnsPerPairBlockOfCurrentLevelCurrentGrouping[currentIntersection])
              {
                if (vector2DStorArrOne[currentIntersection].X <= vector2DStorArrOne[currentIntersection].Y)
                {
                  intersectionDirStorArr.Add(2);
                  intersectionOrientationStorArr.Add(0);
                }
                else
                {
                  intersectionDirStorArr.Add(1);
                  intersectionOrientationStorArr.Add(1);
                }
              }
              else
              {
                intersectionDirStorArr.Add(2);
                intersectionOrientationStorArr.Add(1);
              }
      
            }
            else if (currentFirstOfPairIsAboveSecond)
            {
              if (whichOfEachPairsTurnsBecomesTheIntersection[currentIntersection] == 1)
              {
                if (vector2DStorArrOne[currentIntersection].X <= vector2DStorArrOne[currentIntersection].Y)
                {
                  intersectionDirStorArr.Add(2);
                  intersectionOrientationStorArr.Add(0);
                }
                else
                {
                  intersectionDirStorArr.Add(1);
                  intersectionOrientationStorArr.Add(1);
                }
              }
              else
              {
                intersectionDirStorArr.Add(1);
                intersectionOrientationStorArr.Add(0);
              }
            }
            else
            {
              if (vector2DStorArrOne[currentIntersection].X <= vector2DStorArrOne[currentIntersection].Y)
              {
                intersectionDirStorArr.Add(2);
                intersectionOrientationStorArr.Add(0);
              }
              else
              {
                intersectionDirStorArr.Add(1);
                intersectionOrientationStorArr.Add(1);
              }
            }
            break;
          case 2:
            if (currentFirstOfPairIsEvenWithOrLeftOfSecond)
            {
              if (whichOfEachPairsTurnsBecomesTheIntersection[currentIntersection] == availableTurnsPerPairBlockOfCurrentLevelCurrentGrouping[currentIntersection])
              {
                if (16 - vector2DStorArrOne[currentIntersection].Y <= vector2DStorArrOne[currentIntersection].X)
                {
                  intersectionDirStorArr.Add(3);
                  intersectionOrientationStorArr.Add(0);
                }
                else
                {
                  intersectionDirStorArr.Add(2);
                  intersectionOrientationStorArr.Add(1);
                }
              }
              else
              {
                intersectionDirStorArr.Add(3);
                intersectionOrientationStorArr.Add(1);
              }
      
            }
            else if (currentFirstOfPairIsAboveSecond)
            {
              if (whichOfEachPairsTurnsBecomesTheIntersection[currentIntersection] == 1)
              {
                if (16 - vector2DStorArrOne[currentIntersection].Y <= vector2DStorArrOne[currentIntersection].X)
                {
                  intersectionDirStorArr.Add(3);
                  intersectionOrientationStorArr.Add(0);
                }
                else
                {
                  intersectionDirStorArr.Add(2);
                  intersectionOrientationStorArr.Add(1);
                }
              }
              else
              {
                intersectionDirStorArr.Add(2);
                intersectionOrientationStorArr.Add(0);
              }
            }
            else
            {
              if (16 - vector2DStorArrOne[currentIntersection].Y <= vector2DStorArrOne[currentIntersection].X)
              {
                intersectionDirStorArr.Add(3);
                intersectionOrientationStorArr.Add(0);
              }
              else
              {
                intersectionDirStorArr.Add(2);
                intersectionOrientationStorArr.Add(1);
              }
            }
            break;
          case 3:
            if (currentFirstOfPairIsEvenWithOrLeftOfSecond)
            {
              if (whichOfEachPairsTurnsBecomesTheIntersection[currentIntersection] == availableTurnsPerPairBlockOfCurrentLevelCurrentGrouping[currentIntersection])
              {
                if (16 - vector2DStorArrOne[currentIntersection].X <= 16 - vector2DStorArrOne[currentIntersection].Y)
                {
                  intersectionDirStorArr.Add(4);
                  intersectionOrientationStorArr.Add(0);
                }
                else
                {
                  intersectionDirStorArr.Add(3);
                  intersectionOrientationStorArr.Add(1);
                }
              }
              else
              {
                intersectionDirStorArr.Add(4);
                intersectionOrientationStorArr.Add(1);
              }
      
            }
            else if (currentFirstOfPairIsAboveSecond)
            {
              if (whichOfEachPairsTurnsBecomesTheIntersection[currentIntersection] == 1)
              {
                if (16 - vector2DStorArrOne[currentIntersection].X <= 16 - vector2DStorArrOne[currentIntersection].Y)
                {
                  intersectionDirStorArr.Add(4);
                  intersectionOrientationStorArr.Add(0);
                }
                else
                {
                  intersectionDirStorArr.Add(3);
                  intersectionOrientationStorArr.Add(1);
                }
              }
              else
              {
                intersectionDirStorArr.Add(3);
                intersectionOrientationStorArr.Add(0);
              }
            }
            else
            {
              if (16 - vector2DStorArrOne[currentIntersection].X <= 16 - vector2DStorArrOne[currentIntersection].Y)
              {
                intersectionDirStorArr.Add(4);
                intersectionOrientationStorArr.Add(0);
              }
              else
              {
                intersectionDirStorArr.Add(3);
                intersectionOrientationStorArr.Add(1);
              }
            }
            break;
          case 4:
            if (currentFirstOfPairIsEvenWithOrLeftOfSecond)
            {
              if (whichOfEachPairsTurnsBecomesTheIntersection[currentIntersection] == availableTurnsPerPairBlockOfCurrentLevelCurrentGrouping[currentIntersection])
              {
                if (vector2DStorArrOne[currentIntersection].Y <= 16 - vector2DStorArrOne[currentIntersection].X)
                {
                  intersectionDirStorArr.Add(1);
                  intersectionOrientationStorArr.Add(0);
                }
                else
                {
                  intersectionDirStorArr.Add(4);
                  intersectionOrientationStorArr.Add(1);
                }
              }
              else
              {
                intersectionDirStorArr.Add(1);
                intersectionOrientationStorArr.Add(1);
              }
      
            }
            else if (currentFirstOfPairIsAboveSecond)
            {
              if (whichOfEachPairsTurnsBecomesTheIntersection[currentIntersection] == 1)
              {
                if (vector2DStorArrOne[currentIntersection].Y <= 16 - vector2DStorArrOne[currentIntersection].X)
                {
                  intersectionDirStorArr.Add(1);
                  intersectionOrientationStorArr.Add(0);
                }
                else
                {
                  intersectionDirStorArr.Add(4);
                  intersectionOrientationStorArr.Add(1);
                }
              }
              else
              {
                intersectionDirStorArr.Add(4);
                intersectionOrientationStorArr.Add(0);
              }
            }
            else
            {
              if (vector2DStorArrOne[currentIntersection].Y <= 16 - vector2DStorArrOne[currentIntersection].X)
              {
                intersectionDirStorArr.Add(1);
                intersectionOrientationStorArr.Add(0);
              }
              else
              {
                intersectionDirStorArr.Add(4);
                intersectionOrientationStorArr.Add(1);
              }
            }
            break;
          default:
            break;
          }
        }
      }
              </code>
            </pre>
          </div>

          <br></br>

          <p> Are you with me so far? I'm not: checking out now. I will include the rest of <i>this</i> code here for clarity's sake. The really good stuff is where all the raw data is interpreted, buut nobody wants to read that, so that's being ommitted. </p>

          <pre>
            <code>
              
			//promoting any unpaired holes or intersections into the next level
			if (unpairedHoleOrIntersectionDir != 0)
			{//if I switch putting intersectionDirStorArr and intersectionPosStorArr into permanent storage until after this I might be able to increase efficiency slightly
				turnAndIntersectionDistancesPerPair[currentLevelIndex][currentGroupIndex][availableTurnsPerPairBlockOfCurrentLevelCurrentGrouping.Num()] = { 1 };
				directionsOfTurns[currentLevelIndex][currentGroupIndex][availableTurnsPerPairBlockOfCurrentLevelCurrentGrouping.Num()] = { 2 };//Im setting this to 2 instead of 3 and using intersection orientation to discern whether the intersection is actually straight track

				switch (unpairedHoleOrIntersectionDir)
				{
				case 1:
					vector2DStorArrOne.Add(FVector2D(unpairedHoleOrIntersectionPos.X, unpairedHoleOrIntersectionPos.Y + 1));
					break;
				case 2:
					vector2DStorArrOne.Add(FVector2D(unpairedHoleOrIntersectionPos.X + 1, unpairedHoleOrIntersectionPos.Y));
					break;
				case 3:
					vector2DStorArrOne.Add(FVector2D(unpairedHoleOrIntersectionPos.X, unpairedHoleOrIntersectionPos.Y - 1));
					break;
				case 4:
					vector2DStorArrOne.Add(FVector2D(unpairedHoleOrIntersectionPos.X - 1, unpairedHoleOrIntersectionPos.Y));
					break;
				default:
					break;
				}

				intersectionDirStorArr.Add(unpairedHoleOrIntersectionDir);
				intersectionOrientationStorArr.Add(2);

				//should I wait until later to promote the unpairedDir?

				unpairedHoleOrIntersectionPos = FVector2D(0, 0);
				unpairedHoleOrIntersectionDir = 0;

				firstOfPairIsAboveSecondAllPairs[currentLevelIndex][currentGroupIndex].Add(0);
				firstOfPairIsEvenWithOrLeftOfSecondAllPairs[currentLevelIndex][currentGroupIndex].Add(0);//just after the intersectionadjustments block if there is an unpaired intersection on the next level the level a 0 is added to the adjustment weights array

				//will this intersectionOrientation need to be set to 2 for straight track? or will enough be handled by directionOfTurns it wont matter?
				//make sure this unpaired hole does not get an adjustment in the following code bracket. it shouldnt but just watch out
			}

			// this is where everything gets placed into permanent storage. remember this needs to get moved above the intersection adjustment section
			holeAndIntersectionPositions[currentLevelIndex + 1][currentGroupIndex] = vector2DStorArrOne;
			arrOfTrackDirectionsLeadingAwayFromEachHoleOrIntersection[currentLevelIndex + 1][currentGroupIndex] = intersectionDirStorArr;
			intersectionOrientationsPerGroupPerLevel[currentLevelIndex + 1][currentGroupIndex] = intersectionOrientationStorArr;

			//select intersection position are adjusted and firstOfPairIsAboveSecond and firstOfPairIsEvenWithOrLeftOfSecond are written. It's likely adjustingIntersectionPos will cause problems but i will need to run the code a lot to find these issues. To achieve the adjustment I am not adjusting any vector2D's in permanent storage, but tracking which of all intersections are being ajdusted, and then in temporary storage I am adjusting the vector2DStorArrOne for the purpose of calculating the proceeding track and intersections. all of this means when I build the level I will have to inlcude a distinct functionality to extend an appropriately sized portion of track from any intersection bearing a weight
			intersectionAjustmentWeights.Empty();
			firstOfPairIsAboveSecondArr.Empty();
			firstOfPairIsEvenWithOrLeftOfSecondArr.Empty();

			//currently intersections can still be sandwiched together because im not checking which side of the pair needs the adjustment most MAYBE SOLVED further testing required
			// I have noticed when pairStartsOnDifferentSides the logic needs to be handled as if first of pair is above second when first of pair is level with second which is not the case for when pairStartsOnSameSide MAYBE SOLVED further testing required
			//for all first of pair starts on different side then second in this section should I add logic to make the adjustment go to the intersection closest to its side when one intersection is considerably closer to the middle? this would need to include a check to make sure horizontal distance is greater than 1

			if (vector2DStorArrOne.Num() > 1)
			{
				for (int currentPair = 1; currentPair <= vector2DStorArrOne.Num() / 2; currentPair++)
				{//go through and change the below variables from arrays to single variables if it turns out you aren't using modulo to divine the appropriate index anywhere
					firstOfPairIntersectionPos = vector2DStorArrOne[currentPair * 2 - 2];
					secondOfPairIntersectionPos = vector2DStorArrOne[currentPair * 2 - 1];
					firstOfPairIntersectionDir = intersectionDirStorArr[currentPair * 2 - 2];
					secondOfPairIntersectionDir = intersectionDirStorArr[currentPair * 2 - 1];
					differenceInPairPosition = firstOfPairIntersectionPos - secondOfPairIntersectionPos;
					differenceInPairPositionAbsolute = differenceInPairPosition.GetAbs();

					if (abs(firstOfPairIntersectionDir - secondOfPairIntersectionDir) == 2)
					{//this runs when the current pair of intersections aren't just on different sides but on opposite sides. this currently only works with intersections, I have not written the solution to this problem for holes
						intersectionDirStorArr[currentPair * 2 - 2] = FMath::Clamp((firstOfPairIntersectionDir + 1) % 5, 1, 4);
						intersectionAjustmentWeights.Add(3);

						switch (firstOfPairIntersectionDir)
						{
						case 1:
							firstOfPairIntersectionPos.Y += 1;
							vector2DStorArrOne[currentPair * 2 - 2] = firstOfPairIntersectionPos;
							differenceInPairPosition = firstOfPairIntersectionPos - secondOfPairIntersectionPos;

							if (differenceInPairPosition.X > -1)
							{
								firstOfPairIsAboveSecondArr.Add(1);
								firstOfPairIsEvenWithOrLeftOfSecondArr.Add(0);
							}
							else if (differenceInPairPosition.Y > -1)
							{
								firstOfPairIsAboveSecondArr.Add(0);
								firstOfPairIsEvenWithOrLeftOfSecondArr.Add(1);
							}
							else
							{
								firstOfPairIsAboveSecondArr.Add(0);
								firstOfPairIsEvenWithOrLeftOfSecondArr.Add(0);
							}
							break;
						case 2:
							firstOfPairIntersectionPos.X += 1;
							vector2DStorArrOne[currentPair * 2 - 2] = firstOfPairIntersectionPos;
							differenceInPairPosition = firstOfPairIntersectionPos - secondOfPairIntersectionPos;

							if (differenceInPairPosition.Y < 1)
							{
								firstOfPairIsAboveSecondArr.Add(1);
								firstOfPairIsEvenWithOrLeftOfSecondArr.Add(0);
							}
							else if (differenceInPairPosition.X > -1)
							{
								firstOfPairIsAboveSecondArr.Add(0);
								firstOfPairIsEvenWithOrLeftOfSecondArr.Add(1);
							}
							else
							{
								firstOfPairIsAboveSecondArr.Add(0);
								firstOfPairIsEvenWithOrLeftOfSecondArr.Add(0);
							}
							break;
						case 3:
							firstOfPairIntersectionPos.Y -= 1;
							vector2DStorArrOne[currentPair * 2 - 2] = firstOfPairIntersectionPos;
							differenceInPairPosition = firstOfPairIntersectionPos - secondOfPairIntersectionPos;

							if (differenceInPairPosition.X < 1)
							{
								firstOfPairIsAboveSecondArr.Add(1);
								firstOfPairIsEvenWithOrLeftOfSecondArr.Add(0);
							}
							else if (differenceInPairPosition.Y < 1)
							{
								firstOfPairIsAboveSecondArr.Add(0);
								firstOfPairIsEvenWithOrLeftOfSecondArr.Add(1);
							}
							else
							{
								firstOfPairIsAboveSecondArr.Add(0);
								firstOfPairIsEvenWithOrLeftOfSecondArr.Add(0);
							}
							break;
						case 4:
							firstOfPairIntersectionPos.X -= 1;
							vector2DStorArrOne[currentPair * 2 - 2] = firstOfPairIntersectionPos;
							differenceInPairPosition = firstOfPairIntersectionPos - secondOfPairIntersectionPos;

							if (differenceInPairPosition.Y > -1)
							{
								firstOfPairIsAboveSecondArr.Add(1);
								firstOfPairIsEvenWithOrLeftOfSecondArr.Add(0);
							}
							else if (differenceInPairPosition.X < 1)
							{
								firstOfPairIsAboveSecondArr.Add(0);
								firstOfPairIsEvenWithOrLeftOfSecondArr.Add(1);
							}
							else
							{
								firstOfPairIsAboveSecondArr.Add(0);
								firstOfPairIsEvenWithOrLeftOfSecondArr.Add(0);
							}
							break;
						default:
							break;
						}
					}
					else
					{
						switch (firstOfPairIntersectionDir)
						{
						case 1:
							if (firstOfPairIntersectionDir == secondOfPairIntersectionDir)
							{
								if (differenceInPairPosition.Y > 0)
								{
									firstOfPairIsAboveSecondArr.Add(1);
									firstOfPairIsEvenWithOrLeftOfSecondArr.Add(0);
									firstOfPairIntersectionPos.Y += extentOfAdjustment;
									vector2DStorArrOne[currentPair * 2 - 2] = firstOfPairIntersectionPos;
									intersectionAjustmentWeights.Add(1);
								}
								else if (differenceInPairPosition.X < 1)
								{
									firstOfPairIsAboveSecondArr.Add(0);
									firstOfPairIsEvenWithOrLeftOfSecondArr.Add(1);
									secondOfPairIntersectionPos.Y += extentOfAdjustment;

									vector2DStorArrOne[currentPair * 2 - 1] = secondOfPairIntersectionPos;
									intersectionAjustmentWeights.Add(2);
								}
								else
								{
									if (FMath::RandRange(0, 1) && differenceInPairPosition.Y > -2)
									{//second of pair gets adjustment
										secondOfPairIntersectionPos.Y += extentOfAdjustment;
										vector2DStorArrOne[currentPair * 2 - 1] = secondOfPairIntersectionPos;
										intersectionAjustmentWeights.Add(2);
										differenceInPairPosition = firstOfPairIntersectionPos - secondOfPairIntersectionPos;
									}
									else
									{// first of pair gets adjustment
										firstOfPairIntersectionPos.Y += extentOfAdjustment;
										vector2DStorArrOne[currentPair * 2 - 2] = firstOfPairIntersectionPos;
										intersectionAjustmentWeights.Add(1);
										differenceInPairPosition = firstOfPairIntersectionPos - secondOfPairIntersectionPos;
									}

									if (differenceInPairPosition.Y > 0)
									{
										firstOfPairIsAboveSecondArr.Add(1);
										firstOfPairIsEvenWithOrLeftOfSecondArr.Add(0);
									}
									else if (differenceInPairPosition.X < 1)
									{
										firstOfPairIsAboveSecondArr.Add(0);
										firstOfPairIsEvenWithOrLeftOfSecondArr.Add(1);
									}
									else
									{
										firstOfPairIsAboveSecondArr.Add(0);
										firstOfPairIsEvenWithOrLeftOfSecondArr.Add(0);
									}
								}
							}
							else
							{
								if (differenceInPairPosition.Y > -1)
								{
									firstOfPairIsAboveSecondArr.Add(1);
									firstOfPairIsEvenWithOrLeftOfSecondArr.Add(0);
									firstOfPairIntersectionPos.Y += extentOfAdjustment;
									vector2DStorArrOne[currentPair * 2 - 2] = firstOfPairIntersectionPos;
									intersectionAjustmentWeights.Add(1);
								}
								else if (differenceInPairPosition.X < 1)
								{
									firstOfPairIsAboveSecondArr.Add(0);
									firstOfPairIsEvenWithOrLeftOfSecondArr.Add(1);
									secondOfPairIntersectionPos.X += extentOfAdjustment;

									vector2DStorArrOne[currentPair * 2 - 1] = secondOfPairIntersectionPos;
									intersectionAjustmentWeights.Add(2);
								}
								else
								{
									if (differenceInPairPositionAbsolute.X < 2 || differenceInPairPositionAbsolute.Y < 2)
									{
										if (differenceInPairPosition.Y < -1)
										{//second of pair gets adjustment
											secondOfPairIntersectionPos.X += extentOfAdjustment;
											vector2DStorArrOne[currentPair * 2 - 1] = secondOfPairIntersectionPos;
											intersectionAjustmentWeights.Add(2);
											differenceInPairPosition = firstOfPairIntersectionPos - secondOfPairIntersectionPos;
										}
										else if (differenceInPairPosition.X > 1)
										{// first of pair gets adjustment
											firstOfPairIntersectionPos.Y += extentOfAdjustment;
											vector2DStorArrOne[currentPair * 2 - 2] = firstOfPairIntersectionPos;
											intersectionAjustmentWeights.Add(1);
											differenceInPairPosition = firstOfPairIntersectionPos - secondOfPairIntersectionPos;
										}
										else
										{//no adjustments are made. This logic is a necessity but this case should be avoided at all costs
											intersectionAjustmentWeights.Add(0);
										}
									}
									else
									{
										if (FMath::RandRange(0, 1))
										{//second of pair gets adjustment
											secondOfPairIntersectionPos.X += extentOfAdjustment;
											vector2DStorArrOne[currentPair * 2 - 1] = secondOfPairIntersectionPos;
											intersectionAjustmentWeights.Add(2);
											differenceInPairPosition = firstOfPairIntersectionPos - secondOfPairIntersectionPos;
										}
										else
										{// first of pair gets adjustment
											firstOfPairIntersectionPos.Y += extentOfAdjustment;
											vector2DStorArrOne[currentPair * 2 - 2] = firstOfPairIntersectionPos;
											intersectionAjustmentWeights.Add(1);
											differenceInPairPosition = firstOfPairIntersectionPos - secondOfPairIntersectionPos;
										}
									}

									if (differenceInPairPosition.Y > -1)
									{
										firstOfPairIsAboveSecondArr.Add(1);
										firstOfPairIsEvenWithOrLeftOfSecondArr.Add(0);
									}
									else if (differenceInPairPosition.X < 1)
									{
										firstOfPairIsAboveSecondArr.Add(0);
										firstOfPairIsEvenWithOrLeftOfSecondArr.Add(1);
									}
									else
									{
										firstOfPairIsAboveSecondArr.Add(0);
										firstOfPairIsEvenWithOrLeftOfSecondArr.Add(0);
									}
								}
							}

							break;
						case 2:
							if (firstOfPairIntersectionDir == secondOfPairIntersectionDir)
							{
								if (differenceInPairPosition.X > 0)
								{
									firstOfPairIsAboveSecondArr.Add(1);
									firstOfPairIsEvenWithOrLeftOfSecondArr.Add(0);
									firstOfPairIntersectionPos.X += extentOfAdjustment;
									vector2DStorArrOne[currentPair * 2 - 2] = firstOfPairIntersectionPos;
									intersectionAjustmentWeights.Add(1);
								}
								else if (differenceInPairPosition.Y > -1)
								{
									firstOfPairIsAboveSecondArr.Add(0);
									firstOfPairIsEvenWithOrLeftOfSecondArr.Add(1);
									secondOfPairIntersectionPos.X += extentOfAdjustment;
									vector2DStorArrOne[currentPair * 2 - 1] = secondOfPairIntersectionPos;
									intersectionAjustmentWeights.Add(2);
								}
								else
								{
									if (FMath::RandRange(0, 1) && differenceInPairPosition.X > -2)
									{//second of pair gets adjustment
										secondOfPairIntersectionPos.X += extentOfAdjustment;
										vector2DStorArrOne[currentPair * 2 - 1] = secondOfPairIntersectionPos;
										intersectionAjustmentWeights.Add(2);
										differenceInPairPosition = firstOfPairIntersectionPos - secondOfPairIntersectionPos;
									}
									else
									{// first of pair gets adjustment
										firstOfPairIntersectionPos.X += extentOfAdjustment;
										vector2DStorArrOne[currentPair * 2 - 2] = firstOfPairIntersectionPos;
										intersectionAjustmentWeights.Add(1);
										differenceInPairPosition = firstOfPairIntersectionPos - secondOfPairIntersectionPos;
									}

									if (differenceInPairPosition.X > 0)
									{
										firstOfPairIsAboveSecondArr.Add(1);
										firstOfPairIsEvenWithOrLeftOfSecondArr.Add(0);
									}
									else if (differenceInPairPosition.Y > -1)
									{
										firstOfPairIsAboveSecondArr.Add(0);
										firstOfPairIsEvenWithOrLeftOfSecondArr.Add(1);
									}
									else
									{
										firstOfPairIsAboveSecondArr.Add(0);
										firstOfPairIsEvenWithOrLeftOfSecondArr.Add(0);
									}
								}
							}
							else
							{
								if (differenceInPairPosition.X > -1)
								{
									firstOfPairIsAboveSecondArr.Add(1);
									firstOfPairIsEvenWithOrLeftOfSecondArr.Add(0);
									firstOfPairIntersectionPos.X += extentOfAdjustment;
									vector2DStorArrOne[currentPair * 2 - 2] = firstOfPairIntersectionPos;
									intersectionAjustmentWeights.Add(1);
								}
								else if (differenceInPairPosition.Y > -1)
								{
									firstOfPairIsAboveSecondArr.Add(0);
									firstOfPairIsEvenWithOrLeftOfSecondArr.Add(1);
									secondOfPairIntersectionPos.Y -= extentOfAdjustment;
									vector2DStorArrOne[currentPair * 2 - 1] = secondOfPairIntersectionPos;
									intersectionAjustmentWeights.Add(2);
								}
								else
								{
									if (differenceInPairPositionAbsolute.X < 2 || differenceInPairPositionAbsolute.Y < 2)
									{
										if (differenceInPairPosition.X < -1)
										{//second of pair gets adjustment
											secondOfPairIntersectionPos.Y -= extentOfAdjustment;
											vector2DStorArrOne[currentPair * 2 - 1] = secondOfPairIntersectionPos;
											intersectionAjustmentWeights.Add(2);
											differenceInPairPosition = firstOfPairIntersectionPos - secondOfPairIntersectionPos;
										}
										else if (differenceInPairPosition.Y < -1)
										{// first of pair gets adjustment
											firstOfPairIntersectionPos.X += extentOfAdjustment;
											vector2DStorArrOne[currentPair * 2 - 2] = firstOfPairIntersectionPos;
											intersectionAjustmentWeights.Add(1);
											differenceInPairPosition = firstOfPairIntersectionPos - secondOfPairIntersectionPos;
										}
										else
										{//no adjustments are made. This logic is a necessity but this case should be avoided at all costs
											intersectionAjustmentWeights.Add(0);
										}
									}
									else
									{
										if (FMath::RandRange(0, 1))
										{//second of pair gets adjustment
											secondOfPairIntersectionPos.Y -= extentOfAdjustment;
											vector2DStorArrOne[currentPair * 2 - 1] = secondOfPairIntersectionPos;
											intersectionAjustmentWeights.Add(2);
											differenceInPairPosition = firstOfPairIntersectionPos - secondOfPairIntersectionPos;
										}
										else
										{// first of pair gets adjustment
											firstOfPairIntersectionPos.X += extentOfAdjustment;
											vector2DStorArrOne[currentPair * 2 - 2] = firstOfPairIntersectionPos;
											intersectionAjustmentWeights.Add(1);
											differenceInPairPosition = firstOfPairIntersectionPos - secondOfPairIntersectionPos;
										}
									}
								}

								if (differenceInPairPosition.X > -1)
								{
									firstOfPairIsAboveSecondArr.Add(1);
									firstOfPairIsEvenWithOrLeftOfSecondArr.Add(0);
								}
								else if (differenceInPairPosition.Y > -1)
								{
									firstOfPairIsAboveSecondArr.Add(0);
									firstOfPairIsEvenWithOrLeftOfSecondArr.Add(1);
								}
								else
								{
									firstOfPairIsAboveSecondArr.Add(0);
									firstOfPairIsEvenWithOrLeftOfSecondArr.Add(0);
								}
							}

							break;
						case 3:
							if (firstOfPairIntersectionDir == secondOfPairIntersectionDir)
							{
								if (differenceInPairPosition.Y < 0)
								{
									firstOfPairIsAboveSecondArr.Add(1);
									firstOfPairIsEvenWithOrLeftOfSecondArr.Add(0);
									firstOfPairIntersectionPos.Y -= extentOfAdjustment;
									vector2DStorArrOne[currentPair * 2 - 2] = firstOfPairIntersectionPos;
									intersectionAjustmentWeights.Add(1);
								}
								else if (differenceInPairPosition.X > -1)
								{
									firstOfPairIsAboveSecondArr.Add(0);
									firstOfPairIsEvenWithOrLeftOfSecondArr.Add(1);
									secondOfPairIntersectionPos.Y -= extentOfAdjustment;
									vector2DStorArrOne[currentPair * 2 - 1] = secondOfPairIntersectionPos;
									intersectionAjustmentWeights.Add(2);
								}
								else
								{
									if (FMath::RandRange(0, 1) && differenceInPairPosition.Y < 2)
									{//second of pair gets adjustment
										secondOfPairIntersectionPos.Y -= extentOfAdjustment;
										vector2DStorArrOne[currentPair * 2 - 1] = secondOfPairIntersectionPos;
										intersectionAjustmentWeights.Add(2);
										differenceInPairPosition = firstOfPairIntersectionPos - secondOfPairIntersectionPos;
									}
									else
									{// first of pair gets adjustment
										firstOfPairIntersectionPos.Y -= extentOfAdjustment;
										vector2DStorArrOne[currentPair * 2 - 2] = firstOfPairIntersectionPos;
										intersectionAjustmentWeights.Add(1);
										differenceInPairPosition = firstOfPairIntersectionPos - secondOfPairIntersectionPos;
									}

									if (differenceInPairPosition.Y < 0)
									{
										firstOfPairIsAboveSecondArr.Add(1);
										firstOfPairIsEvenWithOrLeftOfSecondArr.Add(0);
									}
									else if (differenceInPairPosition.X > -1)
									{
										firstOfPairIsAboveSecondArr.Add(0);
										firstOfPairIsEvenWithOrLeftOfSecondArr.Add(1);
									}
									else
									{
										firstOfPairIsAboveSecondArr.Add(0);
										firstOfPairIsEvenWithOrLeftOfSecondArr.Add(0);
									}
								}
							}
							else
							{
								if (differenceInPairPosition.Y < 1)
								{
									firstOfPairIsAboveSecondArr.Add(1);
									firstOfPairIsEvenWithOrLeftOfSecondArr.Add(0);
									firstOfPairIntersectionPos.Y -= extentOfAdjustment;
									vector2DStorArrOne[currentPair * 2 - 2] = firstOfPairIntersectionPos;
									intersectionAjustmentWeights.Add(1);
								}
								else if (differenceInPairPosition.X > -1)
								{
									firstOfPairIsAboveSecondArr.Add(0);
									firstOfPairIsEvenWithOrLeftOfSecondArr.Add(1);
									secondOfPairIntersectionPos.X -= extentOfAdjustment;
									vector2DStorArrOne[currentPair * 2 - 1] = secondOfPairIntersectionPos;
									intersectionAjustmentWeights.Add(2);
								}
								else
								{
									if (differenceInPairPositionAbsolute.X < 2 || differenceInPairPositionAbsolute.Y < 2)
									{
										if (differenceInPairPosition.Y > 1)
										{//second of pair gets adjustment
											secondOfPairIntersectionPos.X -= extentOfAdjustment;
											vector2DStorArrOne[currentPair * 2 - 1] = secondOfPairIntersectionPos;
											intersectionAjustmentWeights.Add(2);
											differenceInPairPosition = firstOfPairIntersectionPos - secondOfPairIntersectionPos;
										}
										else if (differenceInPairPosition.X < -1)
										{// first of pair gets adjustment
											firstOfPairIntersectionPos.Y -= extentOfAdjustment;
											vector2DStorArrOne[currentPair * 2 - 2] = firstOfPairIntersectionPos;
											intersectionAjustmentWeights.Add(1);
											differenceInPairPosition = firstOfPairIntersectionPos - secondOfPairIntersectionPos;
										}
										else
										{//no adjustments are made. This logic is a necessity but this case should be avoided at all costs
											intersectionAjustmentWeights.Add(0);
										}
									}
									else
									{
										if (FMath::RandRange(0, 1))
										{//second of pair gets adjustment
											secondOfPairIntersectionPos.X -= extentOfAdjustment;
											vector2DStorArrOne[currentPair * 2 - 1] = secondOfPairIntersectionPos;
											intersectionAjustmentWeights.Add(2);
											differenceInPairPosition = firstOfPairIntersectionPos - secondOfPairIntersectionPos;
										}
										else
										{// first of pair gets adjustment
											firstOfPairIntersectionPos.Y -= extentOfAdjustment;
											vector2DStorArrOne[currentPair * 2 - 2] = firstOfPairIntersectionPos;
											intersectionAjustmentWeights.Add(1);
											differenceInPairPosition = firstOfPairIntersectionPos - secondOfPairIntersectionPos;
										}
									}
								}

								if (differenceInPairPosition.Y < 1)
								{
									firstOfPairIsAboveSecondArr.Add(1);
									firstOfPairIsEvenWithOrLeftOfSecondArr.Add(0);
								}
								else if (differenceInPairPosition.X > -1)
								{
									firstOfPairIsAboveSecondArr.Add(0);
									firstOfPairIsEvenWithOrLeftOfSecondArr.Add(1);
								}
								else
								{
									firstOfPairIsAboveSecondArr.Add(0);
									firstOfPairIsEvenWithOrLeftOfSecondArr.Add(0);
								}
							}

							break;
						case 4:
							if (firstOfPairIntersectionDir == secondOfPairIntersectionDir)
							{
								if (differenceInPairPosition.X < 0)
								{
									firstOfPairIsAboveSecondArr.Add(1);
									firstOfPairIsEvenWithOrLeftOfSecondArr.Add(0);
									firstOfPairIntersectionPos.X -= extentOfAdjustment;
									vector2DStorArrOne[currentPair * 2 - 2] = firstOfPairIntersectionPos;
									intersectionAjustmentWeights.Add(1);
								}
								else if (differenceInPairPosition.Y < 1)
								{
									firstOfPairIsAboveSecondArr.Add(0);
									firstOfPairIsEvenWithOrLeftOfSecondArr.Add(1);
									secondOfPairIntersectionPos.X -= extentOfAdjustment;
									vector2DStorArrOne[currentPair * 2 - 1] = secondOfPairIntersectionPos;
									intersectionAjustmentWeights.Add(2);
								}
								else
								{
									if (FMath::RandRange(0, 1) && differenceInPairPosition.X < 2)
									{//second of pair gets adjustment
										secondOfPairIntersectionPos.X -= extentOfAdjustment;
										vector2DStorArrOne[currentPair * 2 - 1] = secondOfPairIntersectionPos;
										intersectionAjustmentWeights.Add(2);
										differenceInPairPosition = firstOfPairIntersectionPos - secondOfPairIntersectionPos;
									}
									else
									{// first of pair gets adjustment
										firstOfPairIntersectionPos.X -= extentOfAdjustment;
										vector2DStorArrOne[currentPair * 2 - 2] = firstOfPairIntersectionPos;
										intersectionAjustmentWeights.Add(1);
										differenceInPairPosition = firstOfPairIntersectionPos - secondOfPairIntersectionPos;
									}

									if (differenceInPairPosition.X < 0)
									{
										firstOfPairIsAboveSecondArr.Add(1);
										firstOfPairIsEvenWithOrLeftOfSecondArr.Add(0);
									}
									else if (differenceInPairPosition.Y < 1)
									{
										firstOfPairIsAboveSecondArr.Add(0);
										firstOfPairIsEvenWithOrLeftOfSecondArr.Add(1);
									}
									else
									{
										firstOfPairIsAboveSecondArr.Add(0);
										firstOfPairIsEvenWithOrLeftOfSecondArr.Add(0);
									}
								}
							}
							else
							{
								if (differenceInPairPosition.X < 1)
								{
									firstOfPairIsAboveSecondArr.Add(1);
									firstOfPairIsEvenWithOrLeftOfSecondArr.Add(0);
									firstOfPairIntersectionPos.X -= extentOfAdjustment;
									vector2DStorArrOne[currentPair * 2 - 2] = firstOfPairIntersectionPos;
									intersectionAjustmentWeights.Add(1);
								}
								else if (differenceInPairPosition.Y < 1)
								{
									firstOfPairIsAboveSecondArr.Add(0);
									firstOfPairIsEvenWithOrLeftOfSecondArr.Add(1);
									secondOfPairIntersectionPos.Y += extentOfAdjustment;
									vector2DStorArrOne[currentPair * 2 - 1] = secondOfPairIntersectionPos;
									intersectionAjustmentWeights.Add(2);
								}
								else
								{
									if (differenceInPairPositionAbsolute.X < 2 || differenceInPairPositionAbsolute.Y < 2)
									{
										if (differenceInPairPosition.X > 1)
										{//second of pair gets adjustment
											secondOfPairIntersectionPos.Y += extentOfAdjustment;
											vector2DStorArrOne[currentPair * 2 - 1] = secondOfPairIntersectionPos;
											intersectionAjustmentWeights.Add(2);
											differenceInPairPosition = firstOfPairIntersectionPos - secondOfPairIntersectionPos;
										}
										else if (differenceInPairPosition.Y > 1)
										{// first of pair gets adjustment
											firstOfPairIntersectionPos.X -= extentOfAdjustment;
											vector2DStorArrOne[currentPair * 2 - 2] = firstOfPairIntersectionPos;
											intersectionAjustmentWeights.Add(1);
											differenceInPairPosition = firstOfPairIntersectionPos - secondOfPairIntersectionPos;
										}
										else
										{//no adjustments are made. This logic is a necessity but this case should be avoided at all costs
											intersectionAjustmentWeights.Add(0);
										}
									}
									else
									{
										if (FMath::RandRange(0, 1))
										{//second of pair gets adjustment
											secondOfPairIntersectionPos.Y += extentOfAdjustment;
											vector2DStorArrOne[currentPair * 2 - 1] = secondOfPairIntersectionPos;
											intersectionAjustmentWeights.Add(2);
											differenceInPairPosition = firstOfPairIntersectionPos - secondOfPairIntersectionPos;
										}
										else
										{// first of pair gets adjustment
											firstOfPairIntersectionPos.X -= extentOfAdjustment;
											vector2DStorArrOne[currentPair * 2 - 2] = firstOfPairIntersectionPos;
											intersectionAjustmentWeights.Add(1);
											differenceInPairPosition = firstOfPairIntersectionPos - secondOfPairIntersectionPos;
										}
									}
								}

								if (differenceInPairPosition.X < 1)
								{
									firstOfPairIsAboveSecondArr.Add(1);
									firstOfPairIsEvenWithOrLeftOfSecondArr.Add(0);
								}
								else if (differenceInPairPosition.Y < 1)
								{
									firstOfPairIsAboveSecondArr.Add(0);
									firstOfPairIsEvenWithOrLeftOfSecondArr.Add(1);
								}
								else
								{
									firstOfPairIsAboveSecondArr.Add(0);
									firstOfPairIsEvenWithOrLeftOfSecondArr.Add(0);
								}
							}

							break;
						default:
							break;
						}
					}
				}
			}
			if (vector2DStorArrOne.Num() % 2 == 1)
			{
				intersectionAjustmentWeights.Add(0);
			}//just added this lets hope it works

			adjustmentsAppliedToEachIntersection[currentLevelIndex + 1][currentGroupIndex] = intersectionAjustmentWeights;
			firstOfPairIsAboveSecondAllPairs[currentLevelIndex + 1][currentGroupIndex] = firstOfPairIsAboveSecondArr;
			firstOfPairIsEvenWithOrLeftOfSecondAllPairs[currentLevelIndex + 1][currentGroupIndex] = firstOfPairIsEvenWithOrLeftOfSecondArr;


			// this is the pile of arrays and misc which needs to get reset between every level
			horizontalAndVerticleDistancesBetweenHolesOrIntersections[0].Empty();
			horizontalAndVerticleDistancesBetweenHolesOrIntersections[1].Empty();

			horizontalDistancesBetweenHolesOrIntersections.Empty();
			verticleDistancesBetweenHolesOrIntersections.Empty();

			availableTurnsPerPairBlockOfCurrentLevelCurrentGrouping.Empty();

			whichOfEachPairsTurnsBecomesTheIntersection.Empty();

			firstOfPairHoleOrIntersectionPosStorArr.Empty();
			firstOfPairHoleDirStorArr.Empty();

			pairStartsOnSameSide.Empty();

			intersectionOrientationStorArr.Empty();
		}
	}

	//here all of the resulting intersections from the foundational groupings are being reorganized into one final group on the 4th level
	vector2DStorArrOne.Empty();
	intersectionDirStorArr.Empty();

	for (int currentGroupIndex = 0; currentGroupIndex < listOfHolePositionGroupings.Num(); currentGroupIndex++)
	{
		topLevelIndex = FMath::Clamp(FMath::RoundHalfFromZero((float)listOfHolePositionGroupings[currentGroupIndex] / 2.0f), 1, 3);
		vector2DStorArrOne.Add(holeAndIntersectionPositions[topLevelIndex][currentGroupIndex][0]);
		intersectionDirStorArr.Add(arrOfTrackDirectionsLeadingAwayFromEachHoleOrIntersection[topLevelIndex][currentGroupIndex][0]);
	}
	holeAndIntersectionPositions[4][0] = vector2DStorArrOne;
	arrOfTrackDirectionsLeadingAwayFromEachHoleOrIntersection[4][0] = intersectionDirStorArr;
	currentGroupSize = vector2DStorArrOne.Num();

	// final group of intersections gets adjusted, and firstOfPairIsAboveSecond 
  // and firstOfPairIsEvenWithOrLeftOfSecond are calculated
	intersectionAjustmentWeights.Empty();
	firstOfPairIsAboveSecondArr.Empty();
	firstOfPairIsEvenWithOrLeftOfSecondArr.Empty();

  // below here all of the previous logic is repeated for the final grouping
  // on the 4th level. It get's tricky, so instead of re-feeding the 4th level 
  // back into the same loop logic, I had to just replicate it, with a few 
  // minor tweaks, but it's basically the same.
            </code>
          </pre>

          <div class="row">
            <div class="col-sm mt-3 mt-md-0">
              <figure>

                <picture>
                  <!-- <source media="(max-width: 480px)" srcset="/assets/img/CAPM-480.webp" />
    <source media="(max-width: 800px)" srcset="/assets/img/CAPM-800.webp" />
    <source media="(max-width: 1400px)" srcset="/assets/img/CAPM-1400.webp" />
    -->

                  <!-- Fallback to the original file -->
                  <img class="img-fluid rounded z-depth-1" src="/assets/img/a/l.png"
                    title="figure 7">

                </picture>

              </figure>
            </div>
            <div class="col-sm mt-3 mt-md-0">
              <figure>

                <picture>
                  <!-- <source media="(max-width: 480px)" srcset="/assets/img/dcf-480.webp" />
    <source media="(max-width: 800px)" srcset="/assets/img/dcf-800.webp" />
    <source media="(max-width: 1400px)" srcset="/assets/img/dcf-1400.webp" />
    -->

                  <!-- Fallback to the original file -->
                  <img class="img-fluid rounded z-depth-1" src="/assets/img/a/m.png" title="figure 8">

                </picture>

              </figure>
            </div>
            <div class="col-sm mt-3 mt-md-0">
              <figure>

                <picture>
                  <!-- <source media="(max-width: 480px)" srcset="/assets/img/scrapefin-480.webp" />
    <source media="(max-width: 800px)" srcset="/assets/img/scrapefin-800.webp" />
    <source media="(max-width: 1400px)" srcset="/assets/img/scrapefin-1400.webp" />
    -->

                  <!-- Fallback to the original file -->
                  <img class="img-fluid rounded z-depth-1" src="/assets/img/a/p.png" title="figure 9">

                </picture>

              </figure>
            </div>
          </div>
          <div>
            <ul>
              <li>Seventh: For each group the prior steps will now be repeated, accept with intersections in the place of endpoints. This is "level" two. Notice in group one nothing is happening. This is because all of the endpoints within group one have been connected, group one is complete.</li>
              <li>Eighth: From the track drawn between the level two intersections a turn is chosen to be a new intersection.</li>
              <li>Nineth: all of the groups have now been completed. Now a single "master" group will be formed containing all of the final intersections for each group. Within this master group the steps repeat. There were only two groups in this example so there is only one pair in the master group. track is drawn between them.</li>
            </ul>
          </div>

          <p>It runs without error 100% of the time. Of course it does: it should, and it has to if it's going to sell.</p>
  
        </article>
  
      </div>
  
    </div>
  
    <!-- Footer -->
    <footer class="fixed-bottom">
      <div class="container mt-0">
        © Copyright 2025 Ian Martell. Powered by <a href="https://jekyllrb.com/" target="_blank"
          rel="noopener noreferrer">Jekyll</a>. Hosted by <a href="https://pages.github.com/" target="_blank"
          rel="noopener noreferrer">GitHub Pages</a>.
  
      </div>
    </footer>
  
    <!-- JavaScripts -->
    <!-- jQuery -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"
      integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  
    <!-- Bootsrap & MDB scripts -->
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.2/dist/umd/popper.min.js"
      integrity="sha256-l/1pMF/+J4TThfgARS6KwWrk/egwuVvhRzfLAMQ6Ds4=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.min.js"
      integrity="sha256-SyTu6CwrfOhaznYZPoolVw2rxoY7lKYKQvqbtqN93HI=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js"
      integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script>
  
    <!-- Masonry & imagesLoaded -->
    <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js"
      integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
    <script defer src="/assets/js/masonry.js" type="text/javascript"></script>
  
    <!-- Medium Zoom JS -->
    <script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js"
      integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script>
    <script src="/assets/js/zoom.js"></script><!-- Load Common JS -->
    <script src="/assets/js/common.js"></script>
  
    <!-- MathJax -->
    <script type="text/javascript">
      window.MathJax = {
        tex: {
          tags: 'ams'
        }
      };
    </script>
    <script defer type="text/javascript" id="MathJax-script"
      src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script>
    <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  
  
  </body>
</html>

