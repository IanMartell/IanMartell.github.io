<!DOCTYPE html>
<html lang="en">

  <!-- Head -->
  <head>    <!-- Metadata, OpenGraph and Schema.org -->
    

    <!-- Standard metadata -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Ian Martell | Sorting Your Marbles</title>
    <meta name="author" content="Ian Martell" />
    <meta name="description" content="Sorting Your Marbles overview" />
    <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website" />


    <!-- Bootstrap & MDB -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous" />

    <!-- Fonts & Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

    <!-- Code Syntax Highlighting -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="none" id="highlight_theme_light" />

    <!-- Styles -->
    
    <link rel="shortcut icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>⚡</text></svg>">
    
    <link rel="stylesheet" href="/assets/css/main.css">
    <link rel="canonical" href="https://ianmartell.github.io/projects/1_project/">
    
    <!-- Dark Mode -->
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark" />

    <script src="/assets/js/theme.js"></script>
    <script src="/assets/js/dark_mode.js"></script>
    

  </head>

  <!-- Body -->
  <body class="fixed-top-nav ">
  
    <!-- Header -->
    <header>
  
      <!-- Nav Bar -->
      <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
        <div class="container">
          <a class="navbar-brand title font-weight-lighter" href="https://ianmartell.github.io/"> <span
              class="font-weight-bold"> Ian </span> Martell</a>
              
          <!-- Social Icons -->
          <div class="navbar-brand social">
            <a href="mailto:goodusedigital@gmail.com" title="email"><i class="fas fa-envelope"></i></a>
            <a href="https://github.com/IanMartell" title="GitHub" target="_blank" rel="noopener noreferrer"><i class="fab fa-github"></i></a>
            <!-- <a href="https://www.linkedin.com/in/spencerpao" title="LinkedIn" target="_blank" rel="noopener noreferrer"><i class="fab fa-linkedin"></i></a>
            <a href="https://spencerpao.github.io/feed.xml" title="RSS Feed"><i class="fas fa-rss-square"></i></a> -->
            
          </div>

          <!-- Navbar Toggle -->
          <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav"
            aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar top-bar"></span>
            <span class="icon-bar middle-bar"></span>
            <span class="icon-bar bottom-bar"></span>
          </button>
  
          <div class="collapse navbar-collapse text-right" id="navbarNav">
            <ul class="navbar-nav ml-auto flex-nowrap">
  
              <!-- About -->
              <li class="nav-item ">
                <a class="nav-link" href="/">about</a>
              </li>
  
              <!-- Blog -->
              <li class="nav-item ">
                <a class="nav-link" href="/blog/">blog</a>
              </li>
  
              <!-- Other pages -->
              <li class="nav-item ">
                <a class="nav-link" href="/projects/">projects</a>
              </li>
  
              <!-- Toogle theme mode -->
              <div class="toggle-container">
                <a id="light-toggle">
                  <i class="fas fa-moon"></i>
                  <i class="fas fa-sun"></i>
                </a>
              </div>
            </ul>
          </div>
        </div>
      </nav>
    </header>
  
    <!-- Content -->
    <div class="container mt-5">
      <!-- page.html -->
      <div class="post">
  
        <header class="post-header">
          <a href="https://store.steampowered.com/app/3015900/Sorting_Your_Marbles/">
          <h1 class="post-title">Sorting Your Marbles</h1>
          </a>
          <p class="post-description">My debut title. The goal is simple: guide each colored marble to a flag of the same color by clicking on intersections to control the track's destination.</p>
        </header>

        <article>
          <div class="gifing float-right">
            <figure>
  
              <picture>
                <!-- <source media="(max-width: 480px)" srcset="/assets/img/prof_pic-480.webp" />
      <source media="(max-width: 800px)" srcset="/assets/img/prof_pic-800.webp" />
      <source media="(max-width: 1400px)" srcset="/assets/img/prof_pic-1400.webp" />
      -->
  
                <!-- Fallback to the original file -->
                 <a href="https://store.steampowered.com/app/3015900/Sorting_Your_Marbles/">
                  <img class="img-fluid z-dept-1 rounded" src="/assets/img/game.gif" alt="/assets/img/verticleStorCapsule.png">
                </a>
  
              </picture>
  
            </figure>
          </div>
  
          <div class="clearfix">
            <p> The full value of S.Y.M. can only be expressed through a comprehensive analysis. As all game developers know: a product needs to be fun, but also (approximately) flawless. It's called polish; it's the icing without which there is no cake. To play S.Y.M. for yourself you will need a steam account and to request a key from me, or purchase the <a href="https://store.steampowered.com/app/3015900/Sorting_Your_Marbles/">product</a>. </p>
            
            <p> This breakdown will instead focus primarily on the procedural level randomizer written for this product. While not a complete picture; this summary is designed to highlight the core techniques common throughout the project, and my strengths and limitations.</p>
          </div>
        </article>
  
        <article>
          <p>When planning the procedural generation function it was decided the data should be organized into levels and groups. More on that later. Instead of keeping many different variables for all of this data, all of it is centralized under vectors. And so the procedural generation genesis began with a choice: multi-dimensional vectors (TArrays in this case), or housing multiple dimensions of data in a single dimension vector. </p>
          
          <p>TArray&lt TArray&lt TArray&lt vec2 &gt &gt &gt positionsNested VS TArray&lt vec2 &gt positionsFlat ?</p> 
          
          <p>It comes down to the memory expense vs. the processor expense. With many coding conventions it is preferred to <i>never</i> dynamically allocate memory. All of my vectors are declared and initialized in my header files with placeholder values. So which alternative takes up more memory? If I initiliaze positionsNested with 2 groups, each with 2 depth with 2 rows and 2 columns; will the amount of memory designated be the same as initializing positionsFlat with 16 values? No¹: vectors, and their common analogs, reallocate contiguous memory automatically, as needed. However at every reallocation more memory is reserved than immediately needed to minimize the number of reallocations. Therefore; while positionsNested and positionsFlat both contain exactly 16 vec2, every additional slot of memory alloted to positionsNested equates to 8 vec2. Compared to only 1 vec2 per slot regarding positionsFlat. It is possible to limit the memory reserved for positionsNested, but time consuming to figure out. For now positionsNested consumes more memory. ¹(“STD::Vector.” Cppreference.Com, <a href="https://en.cppreference.com/w/cpp/container/vector">en.cppreference.com/w/cpp/container/vector</a>. Accessed 22 Apr. 2025. )</p>

          <p>What about processor expense? </p>

          <img class="img-fluid z-dept-1 rounded" src="/assets/img/a/z.png" alt="Illustration of multi-dimensional vector composition">

          <p>The preceding illustration shows how to access the desired elements within a single dimensional vector organized to be multi-dimensional. Thats alot of calculation compared to simply inserting the desired value keys shown with the integersNested reference. Accept, that is actually what is happening behind the scenes in the case of the nested vector. The data stored within integersNested is stored in a single dimension in the memory; which is navigated implicitly just as we would explicitly. </p>

          <p>Considering these factors, Sorting Your Marbles implements multi-dimensional vectors. Although single dimensionality simplifies the memory allocation, the nested vectors are easier to read and write.</p>

          <p>These vectors; TArrays in unreal engines case, are the backbone of the procedural generation. How? it's quite simple:</p>
  
          <div class="row">
            <div class="col-sm mt-3 mt-md-0">
              <figure>

                <picture>
                  <!-- <source media="(max-width: 480px)" srcset="/assets/img/PTA-480.webp" />
    <source media="(max-width: 800px)" srcset="/assets/img/PTA-800.webp" />
    <source media="(max-width: 1400px)" srcset="/assets/img/PTA-1400.webp" />
    -->

                  <!-- Fallback to the original file -->
                  <img class="img-fluid rounded z-depth-1" src="/assets/img/a/a.png" title="figure 1">

                </picture>

              </figure>
            </div>
            <div class="col-sm mt-3 mt-md-0">
              <figure>

                <picture>
                  <!-- <source media="(max-width: 480px)" srcset="/assets/img/Arbitrage-480.webp" />
    <source media="(max-width: 800px)" srcset="/assets/img/Arbitrage-800.webp" />
    <source media="(max-width: 1400px)" srcset="/assets/img/Arbitrage-1400.webp" />
    -->

                  <!-- Fallback to the original file -->
                  <img class="img-fluid rounded z-depth-1" src="/assets/img/a/g.png"
                    title="figure 2">

                </picture>

              </figure>
            </div>
            <div class="col-sm mt-3 mt-md-0">
              <figure>

                <picture>
                  <!-- <source media="(max-width: 480px)" srcset="/assets/img/quant-480.webp" />
    <source media="(max-width: 800px)" srcset="/assets/img/quant-800.webp" />
    <source media="(max-width: 1400px)" srcset="/assets/img/quant-1400.webp" />
    -->

                  <!-- Fallback to the original file -->
                  <img class="img-fluid rounded z-depth-1" src="/assets/img/a/h.png" title="figure 3">

                </picture>

              </figure>
            </div>
          </div>
          <div>
            <ul>
              <li>First: a 15 by 15 tile grid is assumed.</li>
              <li>Second: track endpoints are designated randomly along the perimeter of the grid. As many different track endpoints as determined by the player in the level selector.</li>
              <li>Third: the endpoints are grouped into either a group of two, a group of four, or a group of eight. The size of the group is chosen randomly with even probability for any option. These groupings will procede until every endpoint has been grouped. For example, if there are seven endpoints, a group of two could be designated, then a group of four, then another group of four. The first two enpoints would be grouped, then the next four, then the last endpoint would be designated it's own group, by itself.</li>
            </ul>

            <p>The following code is how step two is accomplished. Forewarning: the code is tiresome. It is not recommended for casual readers.</p>

            <pre>
              <code>
void AMyHUD::GenerateHolePositions()
{
  int firstIndexOfCurrentPortionOfViableHolePositionsTempVar;
  int firstIndexOfCurrentPortionOfViableHolePositions = 0;
  int indexOfPreviousEvenHolePosition = 1;
  FVector2D centerOfRotation = FVector2D(8, 8);
  negativeOneZeroOrOne = FMath::RandRange(-1, 1);

  // below note holes is shorthand for endpoints. This section designates 
  // coordinates within the grid system which are be acceptable locations to 
  // place endpoints. The ammount of "viableHoleCoordinates" increases with the 
  // number of endpoints. notice in figure 2 the red dotted lines have no 
  // specified upper bound. It is variable.

  for (int a = 0; a < 12; a++)
  {
    for (int b = 0; b < 2; b++)
    {
      if ((15 - a) < FMath::Clamp((numberOfHoles - 4) / 2, 0, 6) + 9)
      {
        arrOfViableHoleCoordinates.Add(FVector2D(b + 14, 15 - a));
      }

    }
  } 

  arrOfViableHoleCoordinates.Append(arrOfViableHoleCoordinatesBase);
  // holeCoordinatesBase is the fully enclosed plot at the bottom of the figure. 
  // They are always the same so they are just listed out explicitly in the header file.

  for (int a = 0; a < 13; a++)
  {
    for (int b = 0; b < 2; b++)
    {
      if ((4 + a) < FMath::Clamp((numberOfHoles - 4) / 2, 0, 6) + 9)
      {
        arrOfViableHoleCoordinates.Add(FVector2D(2 - b, a + 4));
      }

    }
  }

  // The following code places endpoints somewhat randomly within the designated plots.

  for (int a = 1; a < numberOfHoles + 1; a++)
  {
    int evenHoleRowCorrectionFigure = pow(2 - (indexOfPreviousEvenHolePosition % 2), (a - 1) % 2);

    firstIndexOfCurrentPortionOfViableHolePositionsTempVar = (arrOfViableHoleCoordinates.Num() / 2 / numberOfHoles * a + FMath::RoundHalfFromZero(((float)((arrOfViableHoleCoordinates.Num() / 2) % numberOfHoles) / (float)numberOfHoles) * a)) * 2;

    // this above variable looks complicated but is exactly as it sounds. first 
    // it divides the quantity of viable spaces by two. This is to prevent an 
    // endpoint being placed directly behind another endpoint. then the halved 
    // quantity of viable coordinates is divided by the number of endpoints. this 
    // is the average size of each section of space within which an endpoints 
    // location is randomly chosen. The result of this figure multiplied by a, 
    // plus some other stuff, is the first index of the current portion of viable 
    // hole positions. current as relevant to a, being the index of a specific 
    // endpoint 

    int currentHolePositionCoordinateIndex = (FMath::RandRange(0, ((firstIndexOfCurrentPortionOfViableHolePositionsTempVar - firstIndexOfCurrentPortionOfViableHolePositions) / evenHoleRowCorrectionFigure) - 1) * evenHoleRowCorrectionFigure) + firstIndexOfCurrentPortionOfViableHolePositions;

    // currentHolePositionCoordinateIndex is the determination of where within 
    // the possible endpoint locations the current endpoint in question (a) is 
    // going to be placed.

    //test.Add(currentHolePositionCoordinateIndex);

    holePositions.Add(arrOfViableHoleCoordinates[currentHolePositionCoordinateIndex]);

    // holePositions is a 1 dimensional vec2 TArray. In the next section of the 
    // overarching procedural generation function holePositions will be placed 
    // into the multi-dimensional TArray as the foundational data. Why not do 
    // that here? because one of the dimensions is "grouping". The groupings have 
    // currently not yet been designated. the t

    firstIndexOfCurrentPortionOfViableHolePositions = firstIndexOfCurrentPortionOfViableHolePositionsTempVar;

    if ((a - 1) % 2 == 0)
    {
      indexOfPreviousEvenHolePosition = currentHolePositionCoordinateIndex;
    }
  }

  // below the rest of this code has the potential to rotate all of the endpoint 
  // coordinates by the center of the tile grid. If negativeOneZeroOrOne == -1 
  // the endpoints are rotated 90 degrees clockwise. If 1, 90 degrees counter 
  // clockwise. i.e if -1 the endpoints will no longer form a U shape, but 
  // instead a C shape on the screen.

  if (negativeOneZeroOrOne != 0)
  {
    holeCoordinateOrientation = 0;

    // elsewhere switches based on integers need to be consecutive this switch statement might glitch out
    switch (negativeOneZeroOrOne)
    {
    case -1:
      for (int a = 0; a < holePositions.Num(); a++)
      {
        FVector2D adjustedHolePosition = holePositions[a] - centerOfRotation;

        holePositions[a] = FVector2D(adjustedHolePosition.Y + centerOfRotation.X, -1 * adjustedHolePosition.X + centerOfRotation.Y);
      }

      break;
    case 1:
      for (int a = 0; a < holePositions.Num(); a++)
      {
        FVector2D adjustedHolePosition = holePositions[a] - centerOfRotation;

        holePositions[a] = FVector2D(-1 * adjustedHolePosition.Y + centerOfRotation.X, adjustedHolePosition.X + centerOfRotation.Y);
      }

      break;
    default:
      break;
    }
  }
  else
  {
    holeCoordinateOrientation = 1;
  }
  /*   nested TArray example
  nestedTArr.Add({ 1, 2, 3 });
  nestedTArr.Add({ 4, 5, 6 });
  nestedTArr[0].Add(7);*/
}
              </code>
            </pre>

          <br></br>

          <p>After GenerateHolePositions finishes GenerateTrackShape is called.This is where things start to get complicated. GenerateTrackShape is roughly 4k lines long, so instead of showing it all, it will be broken into chuncks.</p>

            <pre>
              <code>
void AMyHUD::GenerateTrackShape()
{
  int cumulativeGroupingCoverage = 0;
  int countOfLoopsOne = 0;
  TArray<FVector2D> vector2DStorArrOne;
  TArray<int> intStorArrOne;
  int currentGroupSize;
  int unpairedHoleOrIntersectionDir = 0;
  FVector2D unpairedHoleOrIntersectionPos = FVector2D(0, 0);
  int currentFirstOfPairHoleDir;
  TArray<int> firstOfPairHoleDirStorArr;
  TArray<FVector2D> firstOfPairHoleOrIntersectionPosStorArr;
  FVector2D differenceInPairPosition;
  FVector2D differenceInPairPositionAbsolute;
  int differenceInPairPositionClampedX;
  int differenceInPairPositionClampedY;
  TArray<int> availableTurnsPerPairBlockOfCurrentLevelCurrentGrouping;
  int currentATPPBOCLCG;
  TArray<int> verticleDistancesBetweenHolesOrIntersections;
  TArray<int> horizontalDistancesBetweenHolesOrIntersections;
  TArray<int> firstOfPairIsAboveSecondArr; //this array and firstOfPairIsEvenWithOrLeftOfSecondArr will need to have as many zeros as there are pairs for the first level of each group
  int currentFirstOfPairIsAboveSecond;
  TArray<int> firstOfPairIsEvenWithOrLeftOfSecondArr;
  int currentFirstOfPairIsEvenWithOrLeftOfSecond;
  TArray<TArray<int> > horizontalAndVerticleDistancesBetweenHolesOrIntersections = { { 0, 0, 0, 0 }, { 0, 0, 0, 0 } };
  TArray<int> relevantHorizontalAndVerticleDistances = { 0, 0 };
  TArray<int> whichOfEachPairsTurnsBecomesTheIntersection;
  TArray<int> turnDistancesFromFirstOfPairStorArr;
  TArray<int> amountOfTurnsPerDistance = { 0, 0 };
  TArray<int> turnDirectionsStorArr;// 0 for right, 1 for left, 2 for intersection, 3 for straight track
  TArray<int> oneZeroAlternatingArr = { 1, 0, 1, 0, 1 };
  TArray<int> zeroOneAlternatingArr = { 0, 1, 0, 1, 0 };
  FVector2D currentFirstOfPairHoleOrIntersectionPosition;//X being first
  int currentTurnDistance;
  int previousTurnDistance;
  FVector2D currentIntersectionPos;
  TArray<int> pairStartsOnSameSide;
  TArray<int> intersectionDirStorArr;
  TArray<int> intersectionOrientationStorArr;// 0 for right, 1 for left, 2 for straight
  TArray<int> intersectionAjustmentWeights;// 1 for first of pair, 2 for second of pair, 0 for neither
  FVector2D firstOfPairIntersectionPos;
  FVector2D secondOfPairIntersectionPos;
  int firstOfPairIntersectionDir;
  int secondOfPairIntersectionDir;
  bool oneLastThing = false;
  int topLevelIndex;

  // grouping holes in sets of 2, 4, or 8. These are the groupings spoken of in 
  // step 3.
  while (numberOfHoles > cumulativeGroupingCoverage)
  {
    switch (FMath::RandRange((int32)0, (int32)2))
    {
    case 0:
      listOfHolePositionGroupings.Add(2);
      cumulativeGroupingCoverage += 2;
      break;
    case 1:
      listOfHolePositionGroupings.Add(4);
      cumulativeGroupingCoverage += 4;
      break;
    case 2:
      listOfHolePositionGroupings.Add(8);
      cumulativeGroupingCoverage += 8;
      break;
    default:
      break;
    }
  }

  // cutting down the last grouping in the listOfHolePositionGroupings so the 
  // cummulative coverage is the same as the number of holes
  listOfHolePositionGroupings[listOfHolePositionGroupings.Num() - 1] = listOfHolePositionGroupings[listOfHolePositionGroupings.Num() - 1] - (cumulativeGroupingCoverage - numberOfHoles);

  // designating direction of the track leading away from the holes (its always 
  // toward the center) while grouping these designations to correspond with the 
  // holePositionGroupings, and reorganizing holePositions into 
  // holeAndIntersectionPositions while grouping them to correspond with 
  // holePositionGroupings. this is where the multi dimensional TArrays begin
  for (int a = 0; a < listOfHolePositionGroupings.Num(); a++)
  {
    for (int b = 0; b < listOfHolePositionGroupings[a]; b++)
    {
      vector2DStorArrOne.Add(holePositions[countOfLoopsOne]);

      if (holePositions[countOfLoopsOne].X > holePositions[countOfLoopsOne].Y)
      {
        if (16 - holePositions[countOfLoopsOne].X > holePositions[countOfLoopsOne].Y)
        {
          intStorArrOne.Add(1);
        }
        else
        {
          intStorArrOne.Add(4);
        }
      }
      else
      {
        if (holePositions[countOfLoopsOne].X > 16 - holePositions[countOfLoopsOne].Y)
        {
          intStorArrOne.Add(3);
        }
        else
        {
          intStorArrOne.Add(2);
        }
      }

      countOfLoopsOne++;
    }
    arrOfTrackDirectionsLeadingAwayFromEachHoleOrIntersection[0][a] = intStorArrOne;

    holeAndIntersectionPositions[0][a] = vector2DStorArrOne;

    intStorArrOne.Empty();
    vector2DStorArrOne.Empty();

  }
  if (numberOfHoles > 12)
  {
    switch (negativeOneZeroOrOne)
    {
    case -1:
      arrOfTrackDirectionsLeadingAwayFromEachHoleOrIntersection[0][0][0] = 1;
      arrOfTrackDirectionsLeadingAwayFromEachHoleOrIntersection[0][listOfHolePositionGroupings.Num() - 1][listOfHolePositionGroupings[listOfHolePositionGroupings.Num() - 1] - 1] = 3;
      break;
    case 0:
      arrOfTrackDirectionsLeadingAwayFromEachHoleOrIntersection[0][0][0] = 4;
      arrOfTrackDirectionsLeadingAwayFromEachHoleOrIntersection[0][listOfHolePositionGroupings.Num() - 1][listOfHolePositionGroupings[listOfHolePositionGroupings.Num() - 1] - 1] = 2;
      break;
    case 1:
      arrOfTrackDirectionsLeadingAwayFromEachHoleOrIntersection[0][0][0] = 3;
      arrOfTrackDirectionsLeadingAwayFromEachHoleOrIntersection[0][listOfHolePositionGroupings.Num() - 1][listOfHolePositionGroupings[listOfHolePositionGroupings.Num() - 1] - 1] = 1;
      break;
    default:
      break;
    }
  }
  countOfLoopsOne = 0;
              </code>
            </pre>
              
          </div>

          <br></br>  
  
          <div class="row">
            <div class="col-sm mt-3 mt-md-0">
              <figure>

                <picture>
                  <!-- <source media="(max-width: 480px)" srcset="/assets/img/CAPM-480.webp" />
    <source media="(max-width: 800px)" srcset="/assets/img/CAPM-800.webp" />
    <source media="(max-width: 1400px)" srcset="/assets/img/CAPM-1400.webp" />
    -->

                  <!-- Fallback to the original file -->
                  <img class="img-fluid rounded z-depth-1" src="/assets/img/a/i.png"
                    title="figure 4">

                </picture>

              </figure>
            </div>
            <div class="col-sm mt-3 mt-md-0">
              <figure>

                <picture>
                  <!-- <source media="(max-width: 480px)" srcset="/assets/img/dcf-480.webp" />
    <source media="(max-width: 800px)" srcset="/assets/img/dcf-800.webp" />
    <source media="(max-width: 1400px)" srcset="/assets/img/dcf-1400.webp" />
    -->

                  <!-- Fallback to the original file -->
                  <img class="img-fluid rounded z-depth-1" src="/assets/img/a/j.png" title="figure 5">

                </picture>

              </figure>
            </div>
            <div class="col-sm mt-3 mt-md-0">
              <figure>

                <picture>
                  <!-- <source media="(max-width: 480px)" srcset="/assets/img/scrapefin-480.webp" />
    <source media="(max-width: 800px)" srcset="/assets/img/scrapefin-800.webp" />
    <source media="(max-width: 1400px)" srcset="/assets/img/scrapefin-1400.webp" />
    -->

                  <!-- Fallback to the original file -->
                  <img class="img-fluid rounded z-depth-1" src="/assets/img/a/k.png" title="figure 6">

                </picture>

              </figure>
            </div>
          </div>
          <div>
            <ul>
              <li>Fourth: the endpoints are paired. If there are an odd number of endpoints one is left unpaired.</li>
              <li>Fifth: track is calculated between pairs. This includes the verticle and horizontal distance each section of track spans. Also where along those spans turns exist, and what exact orientation each turn has.</li>
              <li>Sixth: for each section of track one of the turns is designated as an intersection. For this to happen the turn must meet certain criteria.</li>
            </ul>

            <p>Once the groups have been established and the bottom level of data is populated in arrOfTrackDirectionsLeadingAwayFromEachHoleOrIntersection and holeAndIntersectionPositions; the cyclical stuff begins with the step 4 stuff.</p>

            <pre>
              <code>
  // This is where the master loop containing the all of the remaining sub 
  // processes for laying out the track is declared and initialized. Once this  
  // is done looping and the resulting data has been packaged, the track is 
  // ready for assembly.
  //so I think once this completes I will promote all the results into the same group on the 4th level and run the level stuff loop one last time. if it works out like this you can change the permanent storage to only have 1 group for the fourth level and beyond. this would restrict you to a maximum of 16 holes but thats probably enough
  for (int currentGroupIndex = 0; currentGroupIndex < listOfHolePositionGroupings.Num(); currentGroupIndex++)
  {
    currentGroupSize = listOfHolePositionGroupings[currentGroupIndex];
  
    for (int currentLevelIndex = 0; currentLevelIndex <= FMath::Clamp(FMath::RoundHalfFromZero((float)currentGroupSize / 2.0f), 1, 3) - 1; currentLevelIndex++)
    {
      if (currentLevelIndex == 0)
      {
        firstOfPairIsAboveSecondArr.Empty();
        firstOfPairIsEvenWithOrLeftOfSecondArr.Empty();
        intersectionAjustmentWeights.Empty();
  
        for (int a = 0; a < currentGroupSize / 2; a++)
        {
          firstOfPairIsAboveSecondArr.Add(0); //this is zero for each endpoint 
          // on the bottom level because the endpoint locations are generated in 
          // accordance with this condition
          firstOfPairIsEvenWithOrLeftOfSecondArr.Add(0);
          intersectionAjustmentWeights.Add(0);
        }
  
        //do I need to permanently store intersection adjustment weights here?
        firstOfPairIsAboveSecondAllPairs[0][currentGroupIndex] = firstOfPairIsAboveSecondArr;
        firstOfPairIsEvenWithOrLeftOfSecondAllPairs[0][currentGroupIndex] = firstOfPairIsEvenWithOrLeftOfSecondArr;
  
        vector2DStorArrOne = holeAndIntersectionPositions[currentLevelIndex][currentGroupIndex];
        intersectionDirStorArr = arrOfTrackDirectionsLeadingAwayFromEachHoleOrIntersection[currentLevelIndex][currentGroupIndex];
      }
  
      if (intersectionDirStorArr.Num() % 2 == 1)
      {
        unpairedHoleOrIntersectionDir = intersectionDirStorArr[intersectionDirStorArr.Num() - 1];
        unpairedHoleOrIntersectionPos = vector2DStorArrOne[vector2DStorArrOne.Num() - 1];
      }
  
      // designating the amount of turns to the next intersection per pair of 
      // holes or intersections, getting the distance between the holes or 
      // intersections and then getting the horizontal and verticle distance 
      // between the holes or intersections. Then checking if the first hole or 
      // intersection of a pair is "above" the other.
  
      for (int a = 1; a <= intersectionDirStorArr.Num() / 2; a++)//this won't run if there is only one element in the current group
      {
        currentFirstOfPairHoleDir = intersectionDirStorArr[a * 2 - 2];
        firstOfPairHoleDirStorArr.Add(currentFirstOfPairHoleDir);
        firstOfPairHoleOrIntersectionPosStorArr.Add(vector2DStorArrOne[a * 2 - 2]);
  
        differenceInPairPosition = firstOfPairHoleOrIntersectionPosStorArr[a - 1] - vector2DStorArrOne[a * 2 - 1];
        differenceInPairPositionAbsolute = differenceInPairPosition.GetAbs();
        differenceInPairPositionClampedX = FMath::Clamp(FMath::RoundToZero((float)differenceInPairPositionAbsolute.X / 2), 0, 2);
        differenceInPairPositionClampedY = FMath::Clamp(FMath::RoundToZero((float)differenceInPairPositionAbsolute.Y / 2), 0, 2);
        //this needs to be altered to take into consideration if firstOfPairIsAboveSecond and if firstOfPairIsEvenWithOrLeftOfSecond. if the pair starts on the same side and firstOfPairIsAboveSecond the verticleDistance must equal the differenceInPairPositionAbsolute unmodified. if the pair starts on different sides and firstOfPairIsEvenWithOrLeftOfSecond horizontalDistance must equal the differenceInPairPositionAbsolute + 1, if the pair starts on different sides and firstOfPairIsAboveSecond verticleDistance must equal the differenceInPairPositionAbsolute + 1
  
        currentFirstOfPairIsAboveSecond = firstOfPairIsAboveSecondArr[a - 1];
        currentFirstOfPairIsEvenWithOrLeftOfSecond = firstOfPairIsEvenWithOrLeftOfSecondArr[a - 1];
  
        if (currentFirstOfPairHoleDir == intersectionDirStorArr[a * 2 - 1])
        {
          pairStartsOnSameSide.Add(1);
  
          if (differenceInPairPositionClampedX <= differenceInPairPositionClampedY)
          { 
            availableTurnsPerPairBlockOfCurrentLevelCurrentGrouping.Add(FMath::RandRange(firstOfPairIsEvenWithOrLeftOfSecondArr[a - 1], differenceInPairPositionClampedX) * 2 + 2);
          }
          else
          {
            availableTurnsPerPairBlockOfCurrentLevelCurrentGrouping.Add(FMath::RandRange(firstOfPairIsEvenWithOrLeftOfSecondArr[a - 1], differenceInPairPositionClampedY) * 2 + 2);
          }
  
          if (currentFirstOfPairIsAboveSecond)
          {
            switch (currentFirstOfPairHoleDir % 2)
            {
            case 0:
              horizontalDistancesBetweenHolesOrIntersections.Add(differenceInPairPositionAbsolute.Y);
              verticleDistancesBetweenHolesOrIntersections.Add(differenceInPairPositionAbsolute.X - 1);
              break;
            case 1:
              horizontalDistancesBetweenHolesOrIntersections.Add(differenceInPairPositionAbsolute.X);//do I need to roundHalfFromZero here or will it translate properly every time here. this could be a good chance to practice writing an error message generator
              verticleDistancesBetweenHolesOrIntersections.Add(differenceInPairPositionAbsolute.Y - 1);
              break;
            default:
              break;
            }
          }
          else if (currentFirstOfPairIsEvenWithOrLeftOfSecond)
          {
            switch (currentFirstOfPairHoleDir % 2)
            {
            case 0:
              horizontalDistancesBetweenHolesOrIntersections.Add(differenceInPairPositionAbsolute.Y + 1);
              verticleDistancesBetweenHolesOrIntersections.Add(differenceInPairPositionAbsolute.X + 1);
              break;
            case 1:
              horizontalDistancesBetweenHolesOrIntersections.Add(differenceInPairPositionAbsolute.X + 1);
              verticleDistancesBetweenHolesOrIntersections.Add(differenceInPairPositionAbsolute.Y + 1);
              break;
            default:
              break;
            }
          }
          else
          {
            switch (currentFirstOfPairHoleDir % 2)
            {
            case 0:
              horizontalDistancesBetweenHolesOrIntersections.Add(differenceInPairPositionAbsolute.Y);
              verticleDistancesBetweenHolesOrIntersections.Add(differenceInPairPositionAbsolute.X + 1);
              break;
            case 1:
              horizontalDistancesBetweenHolesOrIntersections.Add(differenceInPairPositionAbsolute.X);
              verticleDistancesBetweenHolesOrIntersections.Add(differenceInPairPositionAbsolute.Y + 1);
              break;
            default:
              break;
            }
          }
        }
        else
        {
          pairStartsOnSameSide.Add(0);
  
          if (differenceInPairPositionClampedX <= differenceInPairPositionClampedY)
          {
            availableTurnsPerPairBlockOfCurrentLevelCurrentGrouping.Add(FMath::RandRange(FMath::Clamp(firstOfPairIsAboveSecondArr[a - 1] + firstOfPairIsEvenWithOrLeftOfSecondArr[a - 1], 0, 1), differenceInPairPositionClampedX) * 2 + 1);// I just took off a * 2 from the end of the first argument of the RandRange 01/17/24
          }
          else
          {
            availableTurnsPerPairBlockOfCurrentLevelCurrentGrouping.Add(FMath::RandRange(FMath::Clamp(firstOfPairIsAboveSecondArr[a - 1] + firstOfPairIsEvenWithOrLeftOfSecondArr[a - 1], 0, 1), differenceInPairPositionClampedY) * 2 + 1);
          }
  
          if (currentFirstOfPairIsAboveSecond)
          {
            switch (currentFirstOfPairHoleDir % 2)
            {
            case 0:
              horizontalDistancesBetweenHolesOrIntersections.Add(differenceInPairPositionAbsolute.Y - 1);
              verticleDistancesBetweenHolesOrIntersections.Add(differenceInPairPositionAbsolute.X); //just changed this from +1 to + nothing 01/17/24 
              break;
            case 1:
              horizontalDistancesBetweenHolesOrIntersections.Add(differenceInPairPositionAbsolute.X - 1);
              verticleDistancesBetweenHolesOrIntersections.Add(differenceInPairPositionAbsolute.Y); //just changed this from +1 to + nothing 01/17/24 
              break;
            default:
              break;
            }
          }
          else if (currentFirstOfPairIsEvenWithOrLeftOfSecond)
          {
            switch (currentFirstOfPairHoleDir % 2)
            {
            case 0:
              horizontalDistancesBetweenHolesOrIntersections.Add(differenceInPairPositionAbsolute.Y + 1);
              verticleDistancesBetweenHolesOrIntersections.Add(differenceInPairPositionAbsolute.X);
              break;
            case 1:
              horizontalDistancesBetweenHolesOrIntersections.Add(differenceInPairPositionAbsolute.X + 1);
              verticleDistancesBetweenHolesOrIntersections.Add(differenceInPairPositionAbsolute.Y);
              break;
            default:
              break;
            }
          }
          else
          {
            switch (currentFirstOfPairHoleDir % 2)
            {
            case 0:
              horizontalDistancesBetweenHolesOrIntersections.Add(differenceInPairPositionAbsolute.Y - 1);
              verticleDistancesBetweenHolesOrIntersections.Add(differenceInPairPositionAbsolute.X);
              break;
            case 1:
              horizontalDistancesBetweenHolesOrIntersections.Add(differenceInPairPositionAbsolute.X - 1);
              verticleDistancesBetweenHolesOrIntersections.Add(differenceInPairPositionAbsolute.Y);
              break;
            default:
              break;
            }
          }
        }
      }
  
      horizontalAndVerticleDistancesBetweenHolesOrIntersections[0] = horizontalDistancesBetweenHolesOrIntersections;
      horizontalAndVerticleDistancesBetweenHolesOrIntersections[1] = verticleDistancesBetweenHolesOrIntersections;
              </code>
            </pre>

            <br></br>

            <p>Once the track between pairs, for this group, for this level, has been defined an intersection will be determined from one of the turns.</p>

            <pre>
              <code>
      // determining the intersection location. I will also need to rework the 
      // first section of this master loop and at the very least determine 
      // firstOfPairIsAboveSecond and firstOfPairIsEvenWithOrLeftOfSecond here. 
      // As apart of determining intersection Position I will also need to 
      // "reposition" the intersections of all future pairs which you will 
      // weight to recieve an in intersection in close proximity
      vector2DStorArrOne.Empty();
      
      for (int currentPairIndex = 0; currentPairIndex < availableTurnsPerPairBlockOfCurrentLevelCurrentGrouping.Num(); currentPairIndex++)//Im not sure if this needs to run every pair or every holeOrIntersection, I think its pair
      {
        turnDistancesFromFirstOfPairStorArr = turnAndIntersectionDistancesPerPair[currentLevelIndex][currentGroupIndex][currentPairIndex];
        currentIntersectionPos = firstOfPairHoleOrIntersectionPosStorArr[currentPairIndex];
        //so now all I have to do today is finish this code section, and change the firstOfPairIsAboveSecond and firstOfPairIsEvenWithOrLeftOfSecond calculation to on this level after this. can you interweave adjusting the intersection position? come to think of it that will need to occur before calculating firstOfPairIsAboveSecond and firstOfPairIsEvenWithOrLeftOfSecond
      
        currentTurnDistance = turnDistancesFromFirstOfPairStorArr[whichOfEachPairsTurnsBecomesTheIntersection[currentPairIndex] - 1];
      
        if (whichOfEachPairsTurnsBecomesTheIntersection[currentPairIndex] != 1)
        {
          previousTurnDistance = turnDistancesFromFirstOfPairStorArr[whichOfEachPairsTurnsBecomesTheIntersection[currentPairIndex] - 2];//this should be a minus 2 
        }
        else
        {
          previousTurnDistance = 0;
        }
      
        // cases where firstOfPairIsAboveSecond are more complicated. I have 
        // settled on setting the first turn from the firstOfPair to be -1 
        // which should function properly now. however when I build the level I 
        // will need to pay special attention to this
      
        switch (firstOfPairHoleDirStorArr[currentPairIndex])
        {
        case 1:
          if (firstOfPairIsAboveSecondArr[currentPairIndex])//you still need to adjust how horizontal and verticle distances are calculated to account for if firstOfPairIsAboveSecond or if firstOfPairIsEvenWithOrLeftOfSecond
          {
            if (whichOfEachPairsTurnsBecomesTheIntersection[currentPairIndex] % 2 == 1)
            {
              currentIntersectionPos.X -= previousTurnDistance;
              currentIntersectionPos.Y -= currentTurnDistance;
            }
            else
            {
              currentIntersectionPos.X -= currentTurnDistance;
              currentIntersectionPos.Y -= previousTurnDistance;
            }
      
            vector2DStorArrOne.Add(currentIntersectionPos);
          }
          else if (firstOfPairIsEvenWithOrLeftOfSecondArr[currentPairIndex])
          {
            if (whichOfEachPairsTurnsBecomesTheIntersection[currentPairIndex] % 2 == 1)
            {
              currentIntersectionPos.X += previousTurnDistance;
              currentIntersectionPos.Y += currentTurnDistance;
            }
            else
            {
              currentIntersectionPos.X += currentTurnDistance;
              currentIntersectionPos.Y += previousTurnDistance;
            }
      
            vector2DStorArrOne.Add(currentIntersectionPos);
          }
          else
          {
            if (whichOfEachPairsTurnsBecomesTheIntersection[currentPairIndex] % 2 == 1)
            {
              currentIntersectionPos.X -= previousTurnDistance;
              currentIntersectionPos.Y += currentTurnDistance;
            }
            else
            {
              currentIntersectionPos.X -= currentTurnDistance;
              currentIntersectionPos.Y += previousTurnDistance;
            }
      
            vector2DStorArrOne.Add(currentIntersectionPos);
          }
      
          break;
        case 2:
          if (firstOfPairIsAboveSecondArr[currentPairIndex])
          {
            if (whichOfEachPairsTurnsBecomesTheIntersection[currentPairIndex] % 2 == 1)
            {
              currentIntersectionPos.X -= currentTurnDistance;
              currentIntersectionPos.Y += previousTurnDistance;
            }
            else
            {
              currentIntersectionPos.X -= previousTurnDistance;
              currentIntersectionPos.Y += currentTurnDistance;
            }
      
            vector2DStorArrOne.Add(currentIntersectionPos);
          }
          else if (firstOfPairIsEvenWithOrLeftOfSecondArr[currentPairIndex])
          {
            if (whichOfEachPairsTurnsBecomesTheIntersection[currentPairIndex] % 2 == 1)
            {
              currentIntersectionPos.X += currentTurnDistance;
              currentIntersectionPos.Y -= previousTurnDistance;
            }
            else
            {
              currentIntersectionPos.X += previousTurnDistance;
              currentIntersectionPos.Y -= currentTurnDistance;
            }
      
            vector2DStorArrOne.Add(currentIntersectionPos);
          }
          else
          {
            if (whichOfEachPairsTurnsBecomesTheIntersection[currentPairIndex] % 2 == 1)
            {
              currentIntersectionPos.X += currentTurnDistance;
              currentIntersectionPos.Y += previousTurnDistance;
            }
            else
            {
              currentIntersectionPos.X += previousTurnDistance;
              currentIntersectionPos.Y += currentTurnDistance;
            }
      
            vector2DStorArrOne.Add(currentIntersectionPos);
          }
      
          break;
        case 3:
          if (firstOfPairIsAboveSecondArr[currentPairIndex])
          {
            if (whichOfEachPairsTurnsBecomesTheIntersection[currentPairIndex] % 2 == 1)
            {
              currentIntersectionPos.X += previousTurnDistance;
              currentIntersectionPos.Y += currentTurnDistance;
            }
            else
            {
              currentIntersectionPos.X += currentTurnDistance;
              currentIntersectionPos.Y += previousTurnDistance;
            }
      
            vector2DStorArrOne.Add(currentIntersectionPos);
          }
          else if (firstOfPairIsEvenWithOrLeftOfSecondArr[currentPairIndex])
          {
            if (whichOfEachPairsTurnsBecomesTheIntersection[currentPairIndex] % 2 == 1)
            {
              currentIntersectionPos.X -= previousTurnDistance;
              currentIntersectionPos.Y -= currentTurnDistance;
            }
            else
            {
              currentIntersectionPos.X -= currentTurnDistance;
              currentIntersectionPos.Y -= previousTurnDistance;
            }
      
            vector2DStorArrOne.Add(currentIntersectionPos);
          }
          else
          {
            if (whichOfEachPairsTurnsBecomesTheIntersection[currentPairIndex] % 2 == 1)
            {
              currentIntersectionPos.X += previousTurnDistance;
              currentIntersectionPos.Y -= currentTurnDistance;
            }
            else
            {
              currentIntersectionPos.X += currentTurnDistance;
              currentIntersectionPos.Y -= previousTurnDistance;
            }
      
            vector2DStorArrOne.Add(currentIntersectionPos);
          }
      
          break;
        case 4:
          if (firstOfPairIsAboveSecondArr[currentPairIndex])
          {
            if (whichOfEachPairsTurnsBecomesTheIntersection[currentPairIndex] % 2 == 1)
            {
              currentIntersectionPos.X += currentTurnDistance;
              currentIntersectionPos.Y -= previousTurnDistance;
            }
            else
            {
              currentIntersectionPos.X += previousTurnDistance;
              currentIntersectionPos.Y -= currentTurnDistance;
            }
      
            vector2DStorArrOne.Add(currentIntersectionPos);
          }
          else if (firstOfPairIsEvenWithOrLeftOfSecondArr[currentPairIndex])
          {
            if (whichOfEachPairsTurnsBecomesTheIntersection[currentPairIndex] % 2 == 1)
            {
              currentIntersectionPos.X -= currentTurnDistance;
              currentIntersectionPos.Y += previousTurnDistance;
            }
            else
            {
              currentIntersectionPos.X -= previousTurnDistance;
              currentIntersectionPos.Y += currentTurnDistance;
            }
      
            vector2DStorArrOne.Add(currentIntersectionPos);
          }
          else
          {
            if (whichOfEachPairsTurnsBecomesTheIntersection[currentPairIndex] % 2 == 1)
            {
              currentIntersectionPos.X -= currentTurnDistance;
              currentIntersectionPos.Y -= previousTurnDistance;
            }
            else
            {
              currentIntersectionPos.X -= previousTurnDistance;
              currentIntersectionPos.Y -= currentTurnDistance;
            }
      
            vector2DStorArrOne.Add(currentIntersectionPos);
          }
      
          break;
        default:
          break;
        }
      }
      turnDistancesFromFirstOfPairStorArr.Empty();
      intersectionDirStorArr.Empty();
      
      //calculating newly generated intersection's directions and orientations
      for (int currentIntersection = 0; currentIntersection < vector2DStorArrOne.Num(); currentIntersection++)
      {
        currentFirstOfPairIsAboveSecond = firstOfPairIsAboveSecondArr[currentIntersection];
        currentFirstOfPairIsEvenWithOrLeftOfSecond = firstOfPairIsEvenWithOrLeftOfSecondArr[currentIntersection];
      
        if (pairStartsOnSameSide[currentIntersection])
        {
          intersectionDirStorArr.Add(firstOfPairHoleDirStorArr[currentIntersection]);
      
          if (whichOfEachPairsTurnsBecomesTheIntersection[currentIntersection] % 2)
          {
            intersectionOrientationStorArr.Add(1);
          }
          else
          {
            intersectionOrientationStorArr.Add(0);
          }
        }
        else
        {
          switch (firstOfPairHoleDirStorArr[currentIntersection])//are the 16s in this switch statement correct? I think so
          {
          case 1:
            if (currentFirstOfPairIsEvenWithOrLeftOfSecond)
            {
              if (whichOfEachPairsTurnsBecomesTheIntersection[currentIntersection] == availableTurnsPerPairBlockOfCurrentLevelCurrentGrouping[currentIntersection])
              {
                if (vector2DStorArrOne[currentIntersection].X <= vector2DStorArrOne[currentIntersection].Y)
                {
                  intersectionDirStorArr.Add(2);
                  intersectionOrientationStorArr.Add(0);
                }
                else
                {
                  intersectionDirStorArr.Add(1);
                  intersectionOrientationStorArr.Add(1);
                }
              }
              else
              {
                intersectionDirStorArr.Add(2);
                intersectionOrientationStorArr.Add(1);
              }
      
            }
            else if (currentFirstOfPairIsAboveSecond)
            {
              if (whichOfEachPairsTurnsBecomesTheIntersection[currentIntersection] == 1)
              {
                if (vector2DStorArrOne[currentIntersection].X <= vector2DStorArrOne[currentIntersection].Y)
                {
                  intersectionDirStorArr.Add(2);
                  intersectionOrientationStorArr.Add(0);
                }
                else
                {
                  intersectionDirStorArr.Add(1);
                  intersectionOrientationStorArr.Add(1);
                }
              }
              else
              {
                intersectionDirStorArr.Add(1);
                intersectionOrientationStorArr.Add(0);
              }
            }
            else
            {
              if (vector2DStorArrOne[currentIntersection].X <= vector2DStorArrOne[currentIntersection].Y)
              {
                intersectionDirStorArr.Add(2);
                intersectionOrientationStorArr.Add(0);
              }
              else
              {
                intersectionDirStorArr.Add(1);
                intersectionOrientationStorArr.Add(1);
              }
            }
            break;
          case 2:
            if (currentFirstOfPairIsEvenWithOrLeftOfSecond)
            {
              if (whichOfEachPairsTurnsBecomesTheIntersection[currentIntersection] == availableTurnsPerPairBlockOfCurrentLevelCurrentGrouping[currentIntersection])
              {
                if (16 - vector2DStorArrOne[currentIntersection].Y <= vector2DStorArrOne[currentIntersection].X)
                {
                  intersectionDirStorArr.Add(3);
                  intersectionOrientationStorArr.Add(0);
                }
                else
                {
                  intersectionDirStorArr.Add(2);
                  intersectionOrientationStorArr.Add(1);
                }
              }
              else
              {
                intersectionDirStorArr.Add(3);
                intersectionOrientationStorArr.Add(1);
              }
      
            }
            else if (currentFirstOfPairIsAboveSecond)
            {
              if (whichOfEachPairsTurnsBecomesTheIntersection[currentIntersection] == 1)
              {
                if (16 - vector2DStorArrOne[currentIntersection].Y <= vector2DStorArrOne[currentIntersection].X)
                {
                  intersectionDirStorArr.Add(3);
                  intersectionOrientationStorArr.Add(0);
                }
                else
                {
                  intersectionDirStorArr.Add(2);
                  intersectionOrientationStorArr.Add(1);
                }
              }
              else
              {
                intersectionDirStorArr.Add(2);
                intersectionOrientationStorArr.Add(0);
              }
            }
            else
            {
              if (16 - vector2DStorArrOne[currentIntersection].Y <= vector2DStorArrOne[currentIntersection].X)
              {
                intersectionDirStorArr.Add(3);
                intersectionOrientationStorArr.Add(0);
              }
              else
              {
                intersectionDirStorArr.Add(2);
                intersectionOrientationStorArr.Add(1);
              }
            }
            break;
          case 3:
            if (currentFirstOfPairIsEvenWithOrLeftOfSecond)
            {
              if (whichOfEachPairsTurnsBecomesTheIntersection[currentIntersection] == availableTurnsPerPairBlockOfCurrentLevelCurrentGrouping[currentIntersection])
              {
                if (16 - vector2DStorArrOne[currentIntersection].X <= 16 - vector2DStorArrOne[currentIntersection].Y)
                {
                  intersectionDirStorArr.Add(4);
                  intersectionOrientationStorArr.Add(0);
                }
                else
                {
                  intersectionDirStorArr.Add(3);
                  intersectionOrientationStorArr.Add(1);
                }
              }
              else
              {
                intersectionDirStorArr.Add(4);
                intersectionOrientationStorArr.Add(1);
              }
      
            }
            else if (currentFirstOfPairIsAboveSecond)
            {
              if (whichOfEachPairsTurnsBecomesTheIntersection[currentIntersection] == 1)
              {
                if (16 - vector2DStorArrOne[currentIntersection].X <= 16 - vector2DStorArrOne[currentIntersection].Y)
                {
                  intersectionDirStorArr.Add(4);
                  intersectionOrientationStorArr.Add(0);
                }
                else
                {
                  intersectionDirStorArr.Add(3);
                  intersectionOrientationStorArr.Add(1);
                }
              }
              else
              {
                intersectionDirStorArr.Add(3);
                intersectionOrientationStorArr.Add(0);
              }
            }
            else
            {
              if (16 - vector2DStorArrOne[currentIntersection].X <= 16 - vector2DStorArrOne[currentIntersection].Y)
              {
                intersectionDirStorArr.Add(4);
                intersectionOrientationStorArr.Add(0);
              }
              else
              {
                intersectionDirStorArr.Add(3);
                intersectionOrientationStorArr.Add(1);
              }
            }
            break;
          case 4:
            if (currentFirstOfPairIsEvenWithOrLeftOfSecond)
            {
              if (whichOfEachPairsTurnsBecomesTheIntersection[currentIntersection] == availableTurnsPerPairBlockOfCurrentLevelCurrentGrouping[currentIntersection])
              {
                if (vector2DStorArrOne[currentIntersection].Y <= 16 - vector2DStorArrOne[currentIntersection].X)
                {
                  intersectionDirStorArr.Add(1);
                  intersectionOrientationStorArr.Add(0);
                }
                else
                {
                  intersectionDirStorArr.Add(4);
                  intersectionOrientationStorArr.Add(1);
                }
              }
              else
              {
                intersectionDirStorArr.Add(1);
                intersectionOrientationStorArr.Add(1);
              }
      
            }
            else if (currentFirstOfPairIsAboveSecond)
            {
              if (whichOfEachPairsTurnsBecomesTheIntersection[currentIntersection] == 1)
              {
                if (vector2DStorArrOne[currentIntersection].Y <= 16 - vector2DStorArrOne[currentIntersection].X)
                {
                  intersectionDirStorArr.Add(1);
                  intersectionOrientationStorArr.Add(0);
                }
                else
                {
                  intersectionDirStorArr.Add(4);
                  intersectionOrientationStorArr.Add(1);
                }
              }
              else
              {
                intersectionDirStorArr.Add(4);
                intersectionOrientationStorArr.Add(0);
              }
            }
            else
            {
              if (vector2DStorArrOne[currentIntersection].Y <= 16 - vector2DStorArrOne[currentIntersection].X)
              {
                intersectionDirStorArr.Add(1);
                intersectionOrientationStorArr.Add(0);
              }
              else
              {
                intersectionDirStorArr.Add(4);
                intersectionOrientationStorArr.Add(1);
              }
            }
            break;
          default:
            break;
          }
        }
      }
              </code>
            </pre>
          </div>

          <br></br>

          <div class="row">
            <div class="col-sm mt-3 mt-md-0">
              <figure>

                <picture>
                  <!-- <source media="(max-width: 480px)" srcset="/assets/img/CAPM-480.webp" />
    <source media="(max-width: 800px)" srcset="/assets/img/CAPM-800.webp" />
    <source media="(max-width: 1400px)" srcset="/assets/img/CAPM-1400.webp" />
    -->

                  <!-- Fallback to the original file -->
                  <img class="img-fluid rounded z-depth-1" src="/assets/img/a/l.png"
                    title="figure 7">

                </picture>

              </figure>
            </div>
            <div class="col-sm mt-3 mt-md-0">
              <figure>

                <picture>
                  <!-- <source media="(max-width: 480px)" srcset="/assets/img/dcf-480.webp" />
    <source media="(max-width: 800px)" srcset="/assets/img/dcf-800.webp" />
    <source media="(max-width: 1400px)" srcset="/assets/img/dcf-1400.webp" />
    -->

                  <!-- Fallback to the original file -->
                  <img class="img-fluid rounded z-depth-1" src="/assets/img/a/m.png" title="figure 8">

                </picture>

              </figure>
            </div>
            <div class="col-sm mt-3 mt-md-0">
              <figure>

                <picture>
                  <!-- <source media="(max-width: 480px)" srcset="/assets/img/scrapefin-480.webp" />
    <source media="(max-width: 800px)" srcset="/assets/img/scrapefin-800.webp" />
    <source media="(max-width: 1400px)" srcset="/assets/img/scrapefin-1400.webp" />
    -->

                  <!-- Fallback to the original file -->
                  <img class="img-fluid rounded z-depth-1" src="/assets/img/a/n.png" title="figure 9">

                </picture>

              </figure>
            </div>
          </div>
          <div>
            <ul>
              <li>Seventh: For each group the prior steps will now be repeated, accept with intersections in the place of endpoints. This is "level" two. Notice in group one nothing is happening. This is because all of the endpoints within group one have been connected, group one is complete.</li>
              <li>Eighth: From the track drawn between the level two intersections a turn is chosen to be a new intersection.</li>
              <li>Nineth: all of the groups have now been completed. Now a single "master" group will be formed containing all of the final intersections for each group. Within this master group the steps repeat. There were only two groups in this example so there is only one pair in the master group. track is drawn between them.</li>
            </ul>
          </div>
  
          <div class="row">
            <div class="col-sm mt-3 mt-md-0">
              <figure>

                <picture>
                  <!-- <source media="(max-width: 480px)" srcset="/assets/img/Momentum-480.webp" />
    <source media="(max-width: 800px)" srcset="/assets/img/Momentum-800.webp" />
    <source media="(max-width: 1400px)" srcset="/assets/img/Momentum-1400.webp" />
    -->

                  <!-- Fallback to the original file -->
                  <img class="img-fluid rounded z-depth-1" src="/assets/img/Momentum.png"
                    title="step 6">

                </picture>

              </figure>
            </div>
          </div>
          <div class="caption">
            Detailing popular trading, momentum stratgies.
          </div>
  
          <p>Furthermore, I have a video series on how to hypothetically make $1,000,000 with paper trading. <b> I do not
              have a portfolio where this series is modeled after.</b> This video series can be found <a
              href="https://www.youtube.com/watch?v=PXUnovVYzRo&amp;list=PLHT3ZrWZ1pcS-Ct3DHotXuB9oM7R4ui1x"
              target="_blank" rel="noopener noreferrer">here</a></p>
          <div class="row">
            <div class="col-sm mt-3 mt-md-0">
              <a href="https://www.youtube.com/watch?v=PXUnovVYzRo&amp;list=PLHT3ZrWZ1pcS-Ct3DHotXuB9oM7R4ui1x"
                target="_blank" rel="noopener noreferrer">
                <figure>
  
                  <picture>
                    <!-- <source media="(max-width: 480px)" srcset="/assets/img/Road2-480.webp" />
      <source media="(max-width: 800px)" srcset="/assets/img/Road2-800.webp" />
      <source media="(max-width: 1400px)" srcset="/assets/img/Road2-1400.webp" />
      -->
  
                    <!-- Fallback to the original file -->
                    <img class="img-fluid rounded z-depth-1" src="/assets/img/Road2.png"
                      title="Hypothetical Road to Millionaire Status">
  
                  </picture>
  
                </figure>
  
              </a>
            </div>
          </div>
          <div class="caption">
            Hypothetical Road to $1,000,000
          </div>
  
        </article>
  
      </div>
  
    </div>
  
    <!-- Footer -->
    <footer class="fixed-bottom">
      <div class="container mt-0">
        © Copyright 2025 Ian Martell. Powered by <a href="https://jekyllrb.com/" target="_blank"
          rel="noopener noreferrer">Jekyll</a>. Hosted by <a href="https://pages.github.com/" target="_blank"
          rel="noopener noreferrer">GitHub Pages</a>.
  
      </div>
    </footer>
  
    <!-- JavaScripts -->
    <!-- jQuery -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"
      integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  
    <!-- Bootsrap & MDB scripts -->
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.2/dist/umd/popper.min.js"
      integrity="sha256-l/1pMF/+J4TThfgARS6KwWrk/egwuVvhRzfLAMQ6Ds4=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.min.js"
      integrity="sha256-SyTu6CwrfOhaznYZPoolVw2rxoY7lKYKQvqbtqN93HI=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js"
      integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script>
  
    <!-- Masonry & imagesLoaded -->
    <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js"
      integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
    <script defer src="/assets/js/masonry.js" type="text/javascript"></script>
  
    <!-- Medium Zoom JS -->
    <script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js"
      integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script>
    <script src="/assets/js/zoom.js"></script><!-- Load Common JS -->
    <script src="/assets/js/common.js"></script>
  
    <!-- MathJax -->
    <script type="text/javascript">
      window.MathJax = {
        tex: {
          tags: 'ams'
        }
      };
    </script>
    <script defer type="text/javascript" id="MathJax-script"
      src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script>
    <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  
  
  </body>
</html>

